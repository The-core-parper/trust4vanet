\documentclass[]{llncs}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
% \usepackage{amsart}
\usepackage{bussproofs}
\usepackage{url}


%\newtheorem{proposition}{Proposition}
%\newtheorem{thesis}{Thesis}
%\newtheorem{theorem}{Theorem}
%\newtheorem{corollary}{Corollary}
%\newtheorem{lemma}{Lemma}

%opening
\title{A formally verified Trust and Reputation Model for VANET}
\author{Giuseppe Primiero}
\institute{Department of Computer Science\\Middlesex University London\\United Kingdom}



\begin{document}

\maketitle

\begin{abstract}
Vehicle Ad Hoc Networks (VANET) are becoming an important part of intelligent transportation systems. In this context, security and safety requirements need to rely on a combination of agents' reputation and trust relations over the messaging infrastructure in order to maintain a dynamic behaviour evaluation. Ontologically grounded approaches seem to offer optimal coverage and semantic foundation. Unfortunately, even in these cases the formal correctness of the model and the safety of transitive operations within the infrastructure represent potentially disastrous weaknesses. In this paper we offer a proof-theoretical interpretation of such a reputation and trust model for VANET which allows for a formal verification through translation in the Coq proof assistant and guarantees security of transitive information transmissions.
\end{abstract}


\section{Introduction}\label{sec:intro}

This paper provides a proof-theoretical translation of the trust and reputation model for VANET offered in \cite{xxx} in an extension of the natural deduction calculus \texttt{SecureND} from \cite{yyy} and \cite{zzz}. The aim is, first of all, to show that the trust properties instantiated though \texttt{SecureND} faithfully reflect those in transmission across the VANET network; accordingly, non-trustworthy interactions can be proven to be such through a proof-checking method. On a higher level, the model offered by \texttt{SecureND} has been proven formally correct through its translation to a Coq library, and as such the present translation guarantees a similar property for the whole VANET model.


\section{Related Work}\label{sec:related}


\section{\texttt{(un)SecureND}}\label{sec:logic}

$\mathtt{(un)SecureND}$ is a natural deduction calculus defining trust, mistrust and distrust protocols introduced in \cite{primiero_secureND} for the positive fragment  and in \cite{DBLP:conf/ifiptm/Primiero16} for the negation complete extension. We offer here a slightly modified version adapted for the VANET network. In particular, the present version introduces: contexts as sets of sets; formulas with multiple indices to account for service and message numbers; ranking on service characteristics. We start with introducing the language of our logic:

\begin{definition}(\textbf{Syntax of $\mathtt{(un)SecureND}$})\label{def:syntax} %The syntax  is defined by the following alphabet:
	%
	\begin{displaymath}
	\begin{array}{l}
	\mathcal{A}^{\prec}:= \{\mathcal{V, R}\}\\
	\mathcal{V}:= \{v_{1}\prec \ldots \prec v_{n}\}\\
	\mathcal{R}:= \{rsu_{1}\ldots rsu_{n}\}\\
	\mathcal{S}:= \{S_{1}\leq \dots \leq S_{n}\}\\  %\sim\in \{<,\leq, =, \geq, >\}
	\mathcal{C}:= \{C_{1}\leq \dots \leq C_{n}\}\\  %\sim\in \{<,\leq, =, \geq, >\}
	\mathcal{M^{\mathcal{A}}}:= a^{\mathcal{A}}_{S_{i},C_{j}}\mid \neg \phi^{\mathcal{A}}_{i,j}\mid \phi^{\mathcal{A}}_{i,j}\rightarrow \phi^{\mathcal{A}}_{k,l}\mid \phi^{\mathcal{A}}_{i,j}\wedge \phi^{\mathcal{A}}_{k,l}\mid \phi^{\mathcal{A}}_{i,j}\vee \phi^{\mathcal{A}}_{k,l} \mid \bot\\
	mode:= Read(\mathcal{M}^{\mathcal{A}})\mid Write(\mathcal{M}^{\mathcal{A}})\mid Trust(\mathcal{M}^{\mathcal{A}})\\
	RES:= \mathcal{M}^{\mathcal{A}}\mid mode\mid \neg RES\\
	\Gamma^{\mathcal{A}}:= 
	%\{\{\phi^{\mathcal{A}}_{i,j}, \dots, \phi^{\mathcal{A}}_{i,k}\}, \dots, \{\phi^{\mathcal{A}}_{j,l}, \dots, \phi^{\mathcal{A}}_{j,m}\}\}
	\phi^{\mathcal{A}}_{i,j} \mid \phi^{\mathcal{A}}_{i,j} < \phi^{\mathcal{A}}_{k,l} \mid \Gamma^{\mathcal{A}}; \phi^{\mathcal{A}}_{i,j}
	%\{ \phi^{S}_{i}< \dots < \phi^{S}_{n}\}. %\Gamma^{**}:=\{\psi^{**}_{1}, \dots, \psi^{**}_{n}\}\\
	
	\end{array}
	\end{displaymath}
\end{definition}
%

\subsection{Services, Messaging and Protocols}

$\mathcal{M^{\mathcal{A}}}$ is a set of boolean formulae, closed under connectives, expressing messages. The language includes $\bot$ to express conflicts. $\mathcal{A}$ is the set of agents issuing messages and including vehicles $\mathcal{V}$ and RSUs $\mathcal{R}$. Messages are then signed by agents (vehicles or RSU) generating them and with a service number from $\mathcal{S}$ and a message number, so that: $\phi^{v_{i}}_{i,j}$ says that message $\phi$ about service $S_{i}$ and characteristic $j$ is generated by vehicle $v_{i}$. We assume here and throughout that both services $\mathcal{S}$ and characteristics $\mathcal{C}$ of services are given as posets. To simplify notation, a message $^{v_{i}}_{S_{i},C_{j}}$ is usually abbreviated as $^{v_{i}}_{{i},{j}}$. $mode$ is a variable for reading, writing and trusting messages, closed under negation. An agent profile $\Gamma^{\mathcal{A}}$ is the current list of all messages collected by the agent either from other agents or from various available sensors and other networks. For the present purposes, the latter ones will be indexed at their first vehicle or RSU collecting it.


\begin{definition}[Formulas]
A formula $\Gamma^{v}_{i} \vdash_{\mathtt{s}} \phi^{v_{j}}_{i,k}$ says that a message $\phi$ with number $k$ signed from agent $v_{j}$ about service $i$ is validly accessed at step $\mathtt{s}\geq 0$ under the profile of agent $v_{i}$.
\end{definition}

\begin{definition}[Validity]
A formula $\vdash_{\mathtt{s}} \phi^{v_{j}}_{i,k}$ says that a message $\phi$ with number $k$ signed from agent $v_{j}$ about service $i$ holds for \textit{any} agent's profile at step $\mathtt{s}$.
\end{definition}


Messages satisfies a ranking for each agent based on that of services and characteristics:

\begin{definition}\label{def:dependencypackages}
$\phi^{v_{j}}_{i,k}<\phi^{v_{j}}_{i,l}$ iff $C_{k}\leq C_{k} \in S_{i}$ 
%
%says that for agent $v_{j}$ the characteristic $k$ of service $i$ is more important or essential than characteristic $l$ for the same service; then $\phi^{v_{j}}_{i,k} \vdash_{\mathtt{s}}  \phi^{v_{j}}_{i,l}$.
\end{definition}

The order relation between service characteristics induces therefore validity under profile: if a characteristic $i$ is essential to another one $l$ with respect to a service $i$ for an agent $v_{j}$, then that agent will be required to obtain a value for  $i$ in order to validly access a value for $l$. This order relation between service characteristics can then be lifted at the level of services. A partial order relation $\leq$ over $\mathcal{S}\times \mathcal{S}$ intuitively expresses that an order is satisfied across services: 
%$S\leq S'$ means that repository $S$ contains a package that satisfies a dependency for a package in $S'$

\begin{definition}\label{def:orderrepos}
	$S_{i}\leq S_{j}$  iff $\exists \phi^{v_{j}}_{i,k},\phi^{v_{j}}_{j,l}\ s.t.\ \phi^{v_{j}}_{i,k}<\phi^{v_{j}}_{j,l}$.
\end{definition}
%By the first clause in Definition \ref{def:orderrepos}, 
$S_{i}< S_{j}$ means therefore that a service $S_{i}$ is essential for a service $S_{j}$ if there is a message concerning a characteristic of the latter which requires a message about a characteristic of the former. 
%The condition for $\leq$ is satisfied by a dependency relation $\phi_{i}^{A}<\phi_{j}^{A}$ between two packages in the same repository $A$. 
The partial order allows for branching in the hierarchy, so that e.g. $S_{i}<S_{j}<S_{k}$ and $S_{i}<S_{j}<S_{l}$,  i.e. packages in $S_{k},S_{l}$  both require service $S_{j}$ and transitively $S_{i}$, but they have no requirement from each other. 
%By the second clause in Definition \ref{def:orderrepos}, our order relation abstracts from the issue of reciprocal dependencies. As noted in~\cite{DBLP:journals/eceasst/Boender11}, two packages that mutually depend on each other will either be installed together, or not installed at all. They can therefore be considered as a single package for dependency resolution purposes. 


A valid agent profile meets all the requirements and conflicts clauses of all service messages that the user collects.
%Context $\Gamma^{A}$ formalises a list of formulae describing an installation profile with packages from repository $A$, ordered by the dependency relation holding between relevant packages in $A$. 
%An installation profile can be extended by packages obtained by the same repository, denoted by $\Gamma^{A}, \phi^{A}$. 
Rules from Figure \ref{fig:system0} define agent's profile construction from service messages requirements. By Empty Profile, a user profile can be empty (base case); by Message Insertion, the elements in an installation profile are messages; by Requirement Insertion, a profile can be extended by satisfied service requirements; by Profile Extension, if a message holds in an empty profile, it can be added to an existing profile. 
%Notice that unnecessary packages from any repository can still be added: this is possible for packages without dependencies through the Profile Extension rule, but more in general by an application of the Weakening Rule (see Figure \ref{fig:system3}). The result of such a profile extension is denoted by $\Gamma^{A}; \phi^{B}$ and $\Gamma^{A}; \Gamma^{B}$. It is worth noting that Weakening will preserve profile consistency as it requires additionally an instance fo the $trust$ rule (see Figure \ref{fig:system2}). 

\begin{figure*}[t]
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{Empty Profile}
		\UnaryInfC{$\{\}: profile$}
		\DisplayProof
		\qquad
		\AxiomC{$\phi^{v_{j}}_{i,k} \!:\!\mathcal{M}^{v_{j}}$}
		\RightLabel{Message Insertion}
		\UnaryInfC{$ \phi^{v_{j}}_{i,k} \!:\!profile$}
	\end{prooftree}
	
	
	\begin{prooftree}
	   	\AxiomC{$\Gamma^{v_{j}}, \phi^{v_{j}}_{i,k}: profile$}
		\AxiomC{$\Gamma^{v_{j}}, \phi^{v_{j}}_{i,k}\vdash_{\mathtt{s}}  \psi^{v_{k}}_{j,l}$}
		\RightLabel{Requirement Insertion}
		\BinaryInfC{$\Gamma^{v_{j}}, \phi^{v_{j}}_{i,k}< \psi^{v_{k}}_{j,l} \!:\!profile$}
		%\end{prooftree}
	\end{prooftree}


\begin{prooftree}
			\AxiomC{$\Gamma^{v_{i}}: profile$}
			\AxiomC{$\vdash_{\mathtt{s}}  \psi^{v_{k}}_{j,l}$}
			\RightLabel{Profile Extension}
			\BinaryInfC{$\Gamma^{v_{i}};\psi^{v_{k}}_{j,l} \!:\!profile$}
		\end{prooftree}
	
	
	\caption{The System \texttt{(un)SecureND}: Profile Construction Rules}\label{fig:system0}
\end{figure*}




\subsection{Rules for message construction}

The operational rules in Figure \ref{fig:system1} formulate compositionality of messages. 

\begin{figure*}[t]
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}};\Gamma^{v_{j}}: profile$}
		\RightLabel{Atom, for any $\psi^{v_{j}}_{i,l}\in \Gamma^{v_{j}}$}
		\UnaryInfC{$\Gamma^{v_{i}};\Gamma^{v_{j}}\vdash_{\mathtt{s}}  \psi^{v_{j}}_{i,l}$}
		%\end{prooftree}
		\DisplayProof
		\qquad
		%
		%\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}  RES \rightarrow \bot$}
		\RightLabel{$\bot$}
		\UnaryInfC{$\Gamma^{v_{i}}\vdash_{\mathtt{s+1}}  \neg RES$}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l}$}
		\AxiomC{$\Gamma^{v_{j}} \vdash_{\mathtt{s'}}  \psi^{v_{j}}_{i,m}$}
		\RightLabel{$\wedge$-I}
		\BinaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{max(s,s')+1}}  \phi^{v_{i}}_{i,l} \wedge \psi^{v_{j}}_{i,m}$}
		\DisplayProof
		\qquad
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l} \wedge \psi^{v_{j}}_{i,m}$}
		\RightLabel{$\wedge$-E}
		\UnaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s+1}}  \phi/\psi^{v_{i/j}}_{i,l/m}$}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s}}  \phi^{v_{i/j}}_{i,l/m}$}
		\RightLabel{$\vee$-I}
		\UnaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s+1}}  \phi^{v_{i}}_{i,l} \vee \psi^{v_{j}}_{i,m}$}
		\DisplayProof
		\quad
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l} \vee \psi^{v_{j}}_{i,m}$}
		\AxiomC{$\psi^{v_{i/j}}_{i,l/m} \vdash_{\mathtt{s'}}  \xi^{v_{i/j}}_{k,n}$}
		\RightLabel{$\vee$-E}
		\BinaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s'+1}}  \xi^{v_{i/j}}_{k,n}$}
	\end{prooftree}
	
	
	%	with $I\in \{A,B\}, i \in\{1,2\}$ in the above rules.
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}};\phi^{v_{i}}_{i,l}\vdash_{\mathtt{s}}  \psi^{v_{j}}_{i,m}$}
		\RightLabel{$\rightarrow$-I}
		\UnaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s+1}}  \phi^{v_{i}}_{i,l} \rightarrow \psi^{v_{j}}_{i,m}$}
		\DisplayProof
		\qquad
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l} \rightarrow \psi^{v_{j}}_{i,m}$}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s'}}  \phi^{v_{i}}_{i,l}  $}
		\RightLabel{$\rightarrow$-E}
		\BinaryInfC{$\Gamma^{v_{i}};\phi^{v_{i}}_{i,l}\vdash_{\mathtt{s'+1}}  \psi^{v_{j}}_{i,m}$}
	\end{prooftree}
	
	
	
	\caption{The System \texttt{(un)SecureND}: Operational Rules}\label{fig:system1}
\end{figure*}

The rule $Atom$ establishes valid content within a user profile and across other profiles with satisfied requirements. 
%In the present version we assume $A<B$.
$\bot$ formulates access to contradictory messages, in which case the profile must be consistent with the negated access. $\wedge$-I allows message composition from distinct profiles; by $\wedge$-E, each composing message can be obtained from the combined profiles (with $I=\{A,B\}$). $\vee$-I says that a combined profile can access any message produced from each of the composing profiles; by the elimination $\vee$-E, each message consistently inferred by each individual profile can also be executed under the extended profile. $\rightarrow$-Introduction expresses inference of a message from a combined profile as inference between messages (Deduction Theorem); its elimination $\rightarrow$-E allows to recover such inference as profile extension (Modus Ponens).

\subsection{Access Rules}

In Figure \ref{fig:system2} we present the access rules on messages. These allow a user's profile to act on messages from a distinct agent. 


%\Gamma^{v_{i}};\Gamma^{v_{j}}\vdash_{\mathtt{s}}  \psi^{v_{j}}_{i,l}
\begin{figure*}[t]
	\centering
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{s}}  \neg mode(\psi^{v_{j}}_{i,l})$}
		\RightLabel{$\neg$-distribution}
		\UnaryInfC{$\Gamma^{v_{i}}\vdash_{\mathtt{s+1}}  mode(\neg \psi^{v_{j}}_{i,l})$}
		\DisplayProof
		\qquad
		%
		\AxiomC{}
		\RightLabel{$\mathit{read}$}
		\UnaryInfC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})$}
		\end{prooftree}
		
       \begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})$}
		\AxiomC{$\Gamma^{v_{i}};\psi^{v_{j}}_{i,l} : profile$}
		\RightLabel{$\mathit{trust}$}
		\BinaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s+1}}   Trust(\psi^{v_{j}}_{i,l} ) $}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})$}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s'}}   Trust(\psi^{v_{j}}_{i,l} ) $}
		\RightLabel{$\mathit{write}$}
		\BinaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s'+1}}   Write(\psi^{v_{j}}_{i,l} ) $}
		\DisplayProof
		\qquad
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   Write(\psi^{v_{j}}_{i,l} ) $}
		\RightLabel{$\mathit{exec}$}
		\UnaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s+1}}   \psi^{v_{j}}_{i,l}  $}
	\end{prooftree}
	
%	\begin{prooftree}
%%		\AxiomC{$\Gamma^{A}\vdash_{\mathtt{s}}   wf$}
%		\AxiomC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})\rightarrow \bot $}
%		\RightLabel{DTrust-I}
%		\UnaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   \neg Trust(\psi^{v_{j}}_{i,l} ) $}
%		\end{prooftree}
%		%\DisplayProof
%		%\qquad	
%		
%		\begin{prooftree}
%		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   \neg Trust(\psi^{v_{j}}_{i,l} ) $}
%		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   \neg Trust(\psi^{v_{j}}_{i,l}) \rightarrow \xi^{v_{k}}_{i,m}$}
%		\RightLabel{DTrust-E}
%		\BinaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   Write(\xi^{v_{k}}_{i,m}) $}
%	\end{prooftree}
%	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   Read(\psi^{v_{j}}_{i,l})\rightarrow \bot $}
		\AxiomC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\} : profile$}
%		%\vdash_{\mathtt{s}}   wf, $\forall \phi^{A}_{j}\vdash_{\mathtt{s}}  Read(\psi^{B}_{i})\rightarrow \bot $}
		\RightLabel{MTrust-I}
		\BinaryInfC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\} \vdash_{\mathtt{s+1}}   \neg Trust(\neg \psi^{v_{i}}_{i,l})$}
	\end{prooftree}
%	
%
%	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\} \vdash_{\mathtt{s}}   \neg Trust(\neg \psi^{v_{i}}_{i,l})$}
		\AxiomC{$\Gamma^{v_{k}}; \psi^{v_{j}}_{i,j} : profile$}
		\RightLabel{MTrust-E, $\forall v_{k}\prec v_{j}$}
		\BinaryInfC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\};\Gamma^{v_{k}}\vdash_{\mathtt{s+1}}  Trust(\psi^{v_{j}}_{i,l})$}
	\end{prooftree}
	\caption{The System \texttt{(un)SecureND}: Access Rules}\label{fig:system2}
\end{figure*}

%
$\neg$-distribution expresses profile consistency: if a user profile does not allow inferring a message, then it allows inferring any other message that has no requirements including it. $\mathit{read}$ says that from any consistent profile a message can be read provided its requirements are satisfied (if any). $\mathit{trust}$ works as an elimination rule for $read$: it says that if a message is received and it preserves profile consistency, then it can be trusted. $\mathit{write}$ works as an elimination rule for $trust$: it says that a readable and trustable message can be sent over the network. $\mathit{exec}$ says that every message that is safely installed in a consistent profile holds in it. 

%The Introduction rule for distrust DTrust-I expresses the principle that a message non-consistent with its receiving profile can be negated to be trustworthy; the corresponding elimination DTrust-E uses $\rightarrow$-introduction to induce $write$ of any message consistent with the conflict resolution. 
The Introduction rule for mistrust MTrust-I says that currently held message conflicting with a newly arrived message are mistrusted; the corresponding MTrust-E allows to trust any message which is consistent with the conflict resolution by removal of the mistrusted message in the installation profile, including any required dependency, as expressed by the side condition that requires checking for any other agent. 
%By the latter set of rules, 
%\textit{distrust} is a flag for preventing installation of conflicting external packages, while 
\textit{mistrust} is a flag for facilitating removal of messages present in the user profile conflicting in view of incoming new information. 
%Notice that both untrust functions are triggered by the querying operation on a repository, hence conflicts are highlighted before installation.



We can now offer a more general interpretation of the derivability relation $\vdash_{\mathtt{s}} $ as access and execution of some message under a given user profile:
%
\begin{definition}
	A formula $\Gamma^{v_{i}} \vdash_{\mathtt{s}}  RES$ says that a message from some user $v_{k}$ is validly accessed ($mode(\phi^{v_{k}})$) and eventually inferred ($\phi^{v_{k}}$) within a user profile with messages held by user $v_{i}$. 
\end{definition}



\section{Opportunistic Forwarding}

\subsection{Handshaking Protocol}

In the following we present an example derivation mimicking the handshaking protocol. Here Service 1 identifies the set of messages for this protocol.


\begin{figure*}
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}:profile$}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{1}}  hello^{v_{i}}_{1,1}$}
		\RightLabel{Hello Message}
		\BinaryInfC{$\Gamma^{v_{i}}\vdash_{\mathtt{2}}  Write(hello^{v_{i}}_{1,1})$}
		\end{prooftree}

	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{1}}  Write(hello^{v_{i}}_{1,1})$}
		\AxiomC{$\Gamma^{v_{k}}\vdash_{\mathtt{2}}  Read(hello^{v_{i}}_{1,1})$}
				
		\AxiomC{$\Gamma^{v_{k}}; hello^{v_{i}}_{1,1}:profile$}
		\RightLabel{Response Message}
		\TrinaryInfC{$\Gamma^{v_{k}}; hello^{v_{i}}_{1,1}\vdash_{\mathtt{3}}  Write(hello^{v_{k}}_{1,1})$}
		\end{prooftree}


	\caption{The Handshaking Protocol}\label{fig:hadshake}
\end{figure*}

By Hello Message, a user $v_{i}$ with a well-defined profile with a `hello' message in its recognition service sends the message to the network;   a user $v_{k}$ reading the message and assuming it preserves consistency (e.g. there is no instruction in its profile to ingore messages from $v_{i}$), accepts it and forwards it further, including a `hello' back to $v_{i}$.

\subsection{Recipient Selection Protocol}

In the following we present an example derivation mimicking the recipient selection protocol. 


\begin{figure*}
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{k}}; hello^{v_{i}}_{1,1}\vdash_{\mathtt{1}}  Write(hello^{v_{k}}_{1,1})$}
		\AxiomC{$\Gamma^{v_{j}}; hello^{v_{i}}_{1,1}\vdash_{\mathtt{2}}  Write(hello^{v_{j}}_{1,1})$}
		\AxiomC{$v_{k} \prec v_{j}$}
		\RightLabel{Recipient Selection}
		\TrinaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{k}}:profile$}
		\end{prooftree}

	\caption{The Handshaking Protocol}\label{fig:selection}
\end{figure*}


\subsection{Message Passing Protocol}

In the following we present an example derivation mimicking the message passing protocol (without mistrust). Here Service 2 is some service of any kind.


\begin{figure*}
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{k}}:profile$}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{1}}  Write(m^{v_{i}}_{2,1})$}
		\RightLabel{MP}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{2}}  Read(m^{v_{i}}_{2,1})$}
		\AxiomC{$\Gamma^{v_{k}}; m^{v_{i}}_{2,1}: profile$}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{3}}  Trust(m^{v_{i}}_{2,1})$}
		\UnaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{4}}  Write(m^{v_{i}}_{2,1})$}
		\end{prooftree}

	\caption{The Message Passing Protocol}\label{fig:mp}
\end{figure*}


By the first premise in MP, the Handshaking Protocol is guaranteed terminating, including the Recipient Selection protocol if required; $v_{k}$ then reads a message issued by $v_{i}$, checks for validity in its own profile through an application of $trust$, and if this check is passed the message is forwarded.


\section{Reputation Model}

In this section we illustrate the definition of the order relation $\prec$ to formalise the reputation model across agents. Higher reputation is modeled by feedback aggregation. Our system integrates the elements of the main feedback 6-tuple function from \cite{xxx}. In particular, time is mimicked directly by derivation steps (and not accounted in the present model); context is embedded by the user profile; service and characteristics are modelled by messages. To model the set of feedback that a given agent provides with respect to a given message related to a service and characteristic, we will have to collect all formulas following receiving a message:

\begin{definition}[Feedback Set]
The feedback set of agent $v_{j}$ for a message $\phi^{v_{i}}_{i,j}$, for all $v_{j}, v_{i} \in \mathcal{A}$ is the set of formulas $\psi^{v_{j}}_{i,k}$ such that they agree with $\phi^{v_{i}}_{i,j}$ for the service identifier $i$ and are obtained by a derivation construed by a $read$ rule followed by a $\rightarrow I$ rule, i.e.

\[
FS^{v_{j}}(\phi^{v_{i}}_{i,j})=\{ \psi^{v_{j}}_{i,k}\mid \Gamma^{v_{j}}
\vdash_{\mathtt{s}}  Read(\phi^{v_{i}}_{i,j})\rightarrow \psi^{v_{j}}_{i,k}  \}
\]

\end{definition}


By way of example, consider the following simple derivation, which induces $FS^{v_{k}}(m^{v_{i,j}}_{2,1})=\{m^{v_{k}}_{2,2}\}$: 

\begin{figure*}
\begin{tiny}

	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{k}}:profile$}
		\AxiomC{$\Gamma^{v_{j}}; \Gamma^{v_{k}}:profile$}
		\BinaryInfC{$\Gamma^{v_{i}};\Gamma^{v_{j}}; \Gamma^{v_{k}}:profile$}
		
		\AxiomC{$\Gamma^{v_{k}}\vdash_{\mathtt{1}}  Write(m^{v_{i,j}}_{2,1})$}
%		\AxiomC{$\Gamma^{v_{k}}\vdash_{\mathtt{s}}  Write(m^{v_{j}}_{2,1})$}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{2}}  Read(m^{v_{i,j}}_{2,1})$}
		\AxiomC{$\Gamma^{v_{k}}; m^{v_{i,j}}_{2,1}: profile$}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{3}}  Trust(m^{v_{i,j}}_{2,1})$}
		\UnaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{4}}  Write(m^{v_{i,j}}_{2,1})$}
		\AxiomC{$\Gamma^{v_{k}}; m^{v_{i,j}}_{2,1}\vdash_{\mathtt{5}}  m^{v_{k}}_{2,2}$}
        \BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{6}}  m^{v_{i}}_{2,1} \rightarrow m^{v_{k}}_{2,2}$}
		\end{prooftree}
\end{tiny}


	\caption{An Example Feedback Set}\label{fig:ask}

\end{figure*}

Notice that by construction this set includes only feedback to received messages that are consistent with the current user's profile. 

\begin{definition}[Agent's Perception]
The perception of agent $v_{j}$ for a message $\phi^{v_{i}}_{i,j}$, for all $v_{j}, v_{i} \in \mathcal{A}$ is the sum of elements of the feedback set over that formula, weighted by the step of the derivation at which it is obtained: 

\[
AP^{v_{j}}(\phi^{v_{i}}_{i,j})=\sum_{FS^{v_{i}}(\phi^{v_{j}}_{i,k})}(\mathtt{s}(\psi^{v_{j}}_{i,k} \in FS^{v_{i}}(\phi^{v_{j}}_{i,k})))
%\mid \Gamma^{v_{j}}
%\vdash_{\mathtt{s}}  Read(\phi^{v_{i}}_{i,j})\rightarrow \psi^{v_{j}}_{i,k}  \}
\]

\end{definition}

Intuitively, the value of $\mathtt{s}$ at each step of each derivation leading to each formula in the feedback set of an agent to a given service and characteristic is summed up to provide a value that increases linearly to reflect a step value for a time function. The value of $AP^{v_{j}}(\phi^{v_{i}}_{i,j})$ will reflect the aggregation of all the feedback provided on each characteristics of a given service.  


We can now generalize to the set of all feedback on a characteristic for a given service, remembering that these are given in a pre-order so that the position of the characteristic in that order is mapped into an integer:


\begin{definition}[Agent's Perception of Characteristic Set]
The perception of agent $v_{j}$ for a set of messages $\mathcal{M}^{\mathcal{A}}_{S_{i}}$ from agents in $\mathcal{A}$ about service $S_{i}$ 
is the sum of elements of the feedback set over the messages received about that service, weighted by the steps of the derivation at which it is obtained and further by the value $\mathtt{r}(k)$ of the rank of characteristic $k$: 

\[
AP^{v_{j}}(\mathcal{M}^{\mathcal{A}}_{S_{i}})=\sum_{FS^{v_{i}}(\phi^{v_{j}}_{i,k}\dots \phi^{v_{n}}_{i,k})}
(1-\mathtt{r}(k)
(\mathtt{s}(\psi^{v_{j}}_{i,k} \in FS^{v_{i}}(\phi^{v_{j}}_{i,k}\dots \phi^{v_{n}}_{i,k}))))
%\mid \Gamma^{v_{j}}
%\vdash_{\mathtt{s}}  Read(\phi^{v_{i}}_{i,j})\rightarrow \psi^{v_{j}}_{i,k}  \}
\]

\end{definition}


Using the agent's perception of characteristic set, we can define the order of reputation with respect to services, which establishes a higher position for the agent whose perception on the characteristics set for that Service is greater.

\begin{definition}[Reputation]
$\forall v_{i}, v_{j}\in \mathcal{V}, S_{i}\in \mathcal{S}, v_{i}\prec v_{j}:{S_{i}} \leftrightarrow AP^{v_{i}}(\mathcal{M}^{\mathcal{A}}_{S_{i}})>AP^{v_{j}}(\mathcal{M}^{\mathcal{A}}_{S_{i}})$.
\end{definition}

\end{document}

\subsection{Structural Rules}

Structural rules hold with restrictions for $\mathtt{(un)SecureND}$, see Figure \ref{fig:system3}. As a result the system qualifies as substructural, see e.g. \cite{restall}.

\begin{figure*}[t]
	\begin{prooftree}
		\AxiomC{$\Gamma^{A}\vdash_{\mathtt{s}}  Write(\phi^{A}_{i})$}
		\AxiomC{$\Gamma^{A}\vdash_{\mathtt{s}}  Trust(\phi^{B}_{j})$}
		\RightLabel{Profile Weakening}
		\BinaryInfC{$\Gamma^{A}; \phi^{B}_{j}\vdash_{\mathtt{s}}  Write(\phi^{A}_{i})$}
		\end{prooftree}
		
		\begin{prooftree}
		\AxiomC{$\Gamma^{A}, \phi^{A}_{i}; \phi^{B}_{i}\vdash_{\mathtt{s}}  Write(\psi^{A}_{k})$}
		%\AxiomC{$A<B$}
		\RightLabel{Profile Contraction}
		\UnaryInfC{$\Gamma^{A}, \phi^{A}_{i}\vdash_{\mathtt{s}}  Write(\psi^{A}_{k})$}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{A}, \phi^{A}_{i}, \phi^{A}_{j}\vdash_{\mathtt{s}}  Write (\phi^{A}_{k})$}
		\AxiomC{$\phi^{A}_{i}\nless \phi^{A}_{j}$}
		\RightLabel{Profile Exchange}
		\BinaryInfC{$\Gamma^{A}, \phi^{A}_{j}, \phi^{A}_{i}\vdash_{\mathtt{s}}  Write(\phi^{A}_{k})$}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{A} \vdash_{\mathtt{s}}  \phi^{B}_{i}$}
		\AxiomC{$\Gamma^{B}, \phi^{B}_{i}\vdash_{\mathtt{s}}   \phi^{B}_{j}$ }
		\RightLabel{Profile Cut}
		\BinaryInfC{$\Gamma^{A}; \Gamma^{B}\vdash_{\mathtt{s}}   \phi^{B}_{j}$}
	\end{prooftree}
	\caption{The System \texttt{(un)SecureND}: Structural Rules}\label{fig:system3}
\end{figure*}


Weakening is constrained by an instance of $trust$: it says that a valid installation of $\phi^{A}_{i}$ is preserved under a profile extension in view of a trusted package $\phi^{B}_{j}$, i.e. one whose profile extension is provably consistent. 

Contraction is constrained by preservation of package ordering: it says that a valid installation of $\phi^{A}_{k}$ is preserved when removing an instance of identical packages $\phi^{A}_{i}; \phi^{B}_{i}$, provided one removes the package from the higher repository  in the order dependency, so as to guarantee any further dependency below. 

Exchange is doubly constrained by order: it says that a valid installation of $\phi^{A}_{k}$ is preserved under reorder of packages $ \phi^{A}_{i}, \phi^{A}_{j}$, if those come from the same repository $A$ and if there is no involved dependency between them. 

Finally, the Cut rule expresses valid package execution under profile extension: if a package $\phi^{B}_{i}$ is validly executed under profile $\Gamma^{A}$ and a profile $\Gamma^{B}$ including $\phi^{B}_{i}$ allows execution of a package $\phi^{B}_{j}$, then the extended profile $\Gamma^{A}; \Gamma^{B}$ allows execution of $\phi^{B}_{j}$.


\section{The Distrusted Uninstall Problem}\label{sec:distrusted}



Consider a profile $\Gamma^{A}=\{\phi_{1}^{A}< \dots< \phi_{n}^{A}\}$ and a package $\phi_{m}^{B}$ which one wishes \textit{not to install}. This might be due to a principled decision or an explicit conflict in view of an installed package, which one explicitly wants to preserve. We call such a package $\phi_{m}^{B}$ \textit{distrusted}. In the calculus, this corresponds to the conclusion of the DTrust-I rule

$$\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})$$

The \textit{Distrusted Uninstall Problem} is to determine which packages can be installed in $\Gamma^{A}$ that do not depend from $\phi_{m}^{B}$. Our formulation allows to express this principle as the request to obtain the maximal set of formulas $\{\psi_{i}^{N}\}$ from any repository $N\geq B$ such that 

$$\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})\rightarrow \{\psi_{i}^{N}\}$$

By DTrust-E, this guarantees the right to install $\psi_{i}^{N}$. 

The first step consists in transforming our problem in a formulation that removes the trust condition.

\begin{lemma}
	$\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})\rightarrow \psi_{i}^{N}$ iff $\Gamma^{A}; \neg \phi_{m}^{B}\vdash_{\mathtt{s}}  \psi_{i}^{N}$.
\end{lemma}

\begin{proof} 
	For the left-to-right direction: By the assumption $\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})$ and $\neg$-distribution, $\Gamma^{A}\vdash_{\mathtt{s}}  Trust(\neg \phi_{m}^{B})$; by the same rule and the premise $\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})\rightarrow \psi_{i}^{N}$ we get $\Gamma^{A}\vdash_{\mathtt{s}}  Trust( \neg\phi_{m}^{B})\rightarrow \psi_{i}^{N}$. Now apply $write$ to both occurrences of $Trust( \neg\phi_{m}^{B})$ and eliminate the function through $exec$; by $\rightarrow$-E we obtain $\Gamma^{A}; \neg \phi_{m}^{B}\vdash_{\mathtt{s}}  \psi_{i}^{N}$.
	
	For the right-to-left direction: By the assumption $\Gamma^{A}; \neg \phi_{m}^{B}\vdash_{\mathtt{s}}  \psi_{i}^{N}$ it holds $\Gamma^{A}; \neg \phi^{B}_{m}: profile$, which justifies $\Gamma^{A}\vdash_{\mathtt{s}}  Read(\neg \phi^{B}_{m})$ by $read$, $\Gamma^{A}\vdash_{\mathtt{s}}  Trust(\neg \phi^{B}_{m})$ by the previous and $trust$ and $\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust( \phi^{B}_{m})$ by $\neg$-distribution. It follows $\Gamma^{A}; \neg Trust( \phi^{B}_{m})\vdash_{\mathtt{s}}  \psi_{i}^{N}$ by substitution from the assumption, and $\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})\rightarrow \psi_{i}^{N}$ is obtained by $\rightarrow$-I.
	%By $trust$, $write$, $\rightarrow$-E and $\neg$-distribution.
\end{proof}


We can now reduce the latter to an operation on all packages coming from the repository involved by the distrust operation:


\begin{lemma}\label{th:setminus}
	%The Distrust Uninstall Problem is equivalent to a proof of 
	If $\Gamma^{A}; \neg \phi_{m}^{B}\vdash_{\mathtt{s}}  \psi_{i}^{N}$ then $\Gamma^{A}; \Gamma^{B}\setminus \{\phi_{m}^{B}\}\vdash_{\mathtt{s}}  \psi_{i}^{N}$.
\end{lemma}

\begin{proof} 
	
$\Gamma^{A}$ can be extended with every package from $B$; by definition $\Gamma^{A}; \neg \phi_{m}^{B}\vdash_{\mathtt{s}}  \neg Trust(\phi^{B}_{m})$, hence by Weakening this is possible except for $\phi^{B}_{m}$ as it does not satisfy $trust$.
\end{proof}

The above corresponds to finding the maximal set of formulas in $\Gamma^{B}$ that allows to execute $\psi_{i}^{N}$ without requiring $\phi_{m}^{B}$ in the profile. To this aim, it is enough to find all $\phi_{l}^{B}\nless\phi_{m}^{B}$, i.e. the set of packages in $B$ that have no dependencies from $\phi_{m}^{B}$. 

What has been so far restricted to one repository, can now be generalised to any repository that preserves the dependency condition:


\begin{lemma}\label{th:gen}
	$\Gamma^{A};\phi_{l}^{N}\vdash_{\mathtt{s}}  Write(\phi_{i}^{N})$ iff 
	%$(\phi_{l}^{N}<\phi_{m}^{N})$ 
	$(\phi_{l}^{N}\nless \phi_{m}^{N} \nless \psi^{N}_{i})$  for any distrusted package $\phi_{m}^{N}$ and any repository $N> A$.
\end{lemma}

\begin{proof} 
	For the right-to-left direction. Assume the following: $\Gamma^{A};\phi_{l}^{N}\vdash_{\mathtt{s}}  Write(\phi_{i}^{N})$ and $\Gamma^{A};\phi_{l}^{N}\vdash_{\mathtt{s}}  \neg Trust(\phi^{N}_{m})$. Then: if $\phi^{N}_{l}< \phi^{N}_{m}$, then $\Gamma^{A}; \phi^{N}_{l}\vdash_{\mathtt{s}}  \phi^{N}_{m}$ by Atom, contradicting the distrust assumption; and if $\phi^{N}_{m}< \phi^{N}_{i}$ then similarly $\phi^{N}_{m}\vdash_{\mathtt{s}}  \phi^{N}_{i}$ and by Weakening it is possible to obtain $\Gamma^{A};\phi_{l}^{N},\phi^{N}_{m} \vdash_{\mathtt{s}}  Write(\phi_{i}^{N})$, again contradicting the distrust assumption.
	
	For the left-to-right direction. Assume $(\phi_{l}^{N}\nless \phi_{m}^{N} \nless \phi^{N}_{i})$ and $\Gamma^{A};\phi_{l}^{N}\vdash_{\mathtt{s}}  \neg Trust(\phi^{N}_{m})$. Then: because $\phi_{l}^{N}\nless \phi_{m}^{N}$, the second assumption above does not require to remove $\phi_{l}^{N}$ as by Lemma \ref{th:setminus}; and because $\phi_{m}^{N} \nless \phi^{N}_{i}$, installing the latter does not require installing the former, as prescribed by Definition \ref{def:dependencypackages} via the $exec$ rule. Hence $\Gamma^{A};\phi_{l}^{N}\vdash_{\mathtt{s}}  Write(\phi_{i}^{N})$ holds.
\end{proof}

Finally, our main result is obtained:

\begin{theorem}(\textbf{Distrusted Uninstall})
	Given a package $\phi^{B}_{m}$ distrusted under profile $\Gamma^{A}$, a package $\phi^{N}_{i}$ can be installed in $\Gamma^{A}$ iff $\phi^{B}_{m}\nleq \phi^{N}_{i}$.
\end{theorem}

\begin{proof} 
	From Definition \ref{def:distrustedproblem} and Lemma \ref{th:gen} by substitution.
\end{proof}

This last result identifies distrusted packages as those that have at least a dependency from one package conflicting with the current installation profile.


\section{The Mistrusted Uninstall Problem}\label{sec:mistrusted}

Consider a profile $\Gamma^{A}=\{\phi_{1}^{A}, \dots, \phi_{n}^{A}\}$, and a package $\phi^{B}_{m}$ which one wishes to install in it: in the calculus, this corresponds to the conclusion of an instance of the Write rule, $\Gamma^{A}\vdash_{\mathtt{s}}  Write(\phi^{B}_{m})$. Assume that $\phi^{B}_{m}$ is in conflict with the given profile 

$$\Gamma^{A}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m}) \rightarrow \bot$$

The \textit{Mistrusted Uninstall Problem} is to determine the set $\{\phi^{A}_{i}\}$ of packages in $\Gamma^{A}$ that are in conflict with $\phi^{B}_{m}$ and which should be removed when installing it. We will call any such package $\phi^{A}_{i}$ a \textit{mistrusted package}. Hence the problem is to identify the minimal set of formulas $\phi_{i}^{A}$ such that

$$\Gamma^{A}\setminus \{\phi^{A}_{i}\}; \phi^{B}_{m}\vdash_{\mathtt{s}}  \neg Trust(\phi^{A})$$

and by MTrust-E, given any other set of formulas $\Gamma^{C}$ required by $\phi^{B}_{m}$, it allows 

$$\Gamma^{A}\setminus \{\phi^{A}_{i}\}; \Gamma^{C} \vdash_{\mathtt{s}}  Trust(\phi^{B}_{m})$$


We start by identifying the minimal subset of packages from the current installation profile that satisfies the conflict:

\begin{lemma}\label{th:gen2}
	If $\Gamma^{A}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$, then $\exists \Gamma'^{A}\subseteq\Gamma^{A}$
	such that $ \Gamma'^{A}=\{\phi^{A}_{i}< \dots< \phi^{A}_{n}\} \vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$.
%such that $\Gamma'^{A}\ni \phi^{A}_{i}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$ and $\forall \phi^{A}_{j}> \phi^{A}_{i}, \phi^{A}_{j}\in \Gamma'^{A}$
\end{lemma}
%
\begin{proof} 
$\forall \phi^{A}_{i}, \phi^{A}_{j}\in \Gamma^{A}$, if $\phi^{A}_{i}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$ and $\phi^{A}_{i}<\phi^{A}_{j}$, then $\phi^{A}_{j}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$. And $\forall \phi^{A}_{h}<\phi^{A}_{i}$, $\phi^{A}_{h}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})$. Hence it suffices to identify the maximal $\phi^{A}_{i}$ in conflict with $\phi^{B}_{m}$ and to include it in $\Gamma'^{A}$ together with all packages in $\Gamma^{A}$ that depend from it. We will call $\Gamma'^{A}$ a maximally mistrusted set.
\end{proof}


\begin{lemma}\label{th:gen3.0}
Consider a maximally mistrusted $\Gamma'^{A}\subseteq \Gamma^{A}$ such that\\ $ \Gamma'^{A} \vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$ as of Lemma \ref{th:gen2}. Then $\forall \phi^{A}_{i}\in \Gamma'^{A}$, $\phi^{A}_{i} < Read(\phi^{B}_{m})\rightarrow \bot$.
\end{lemma}

\begin{proof}
This holds by construction of $\Gamma'^{A}$ in Lemma \ref{th:gen2} and the Dependency Insertion Rule.
\end{proof}

%\begin{definition}
%	If $\phi^{A}_{i}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$ then $\forall \phi^{A}_{j}>\phi^{A}_{i}, \phi^{A}_{j}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$.
%\end{definition}



\begin{lemma}\label{th:gen3}
	If $\phi^{A}_{i}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$, then $ \phi^{A}_{i}\nless \phi_{m}^{B}$.
\end{lemma}
%
%\begin{proof} 
%XX
%\end{proof}
%
%
%\begin{theorem}\label{th:mis1}
%	$\Gamma^{A}\setminus \{\phi^{A}_{i}\}; \Delta^{C} \vdash_{\mathtt{s}}  Trust(\phi^{B}_{m})$ iff $ \phi^{A}_{i}\nless \phi_{m}^{B}$.
%\end{theorem}

\begin{proof} 
Staring from $\phi^{A}_{i}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$ we apply D-Trust-I, $\neg$-distribution, $write$ and  $exec$ to obtain $\phi^{A}_{i}\vdash_{\mathtt{s}}  \neg \phi^{B}_{m}$, from which we can obtain $\phi^{A}_{i}< \neg \phi^{B}_{m}$ from Dependency Insertion and $\phi^{A}_{i}\nless \phi^{B}_{m}$ by contrapposition.

\end{proof}


%To obtain the set $\{\phi^{A}_{i}\}$, we need to check $$\forall \phi_{i}^{A}\in\Gamma^{A}, \phi^{A}_{i}\vdash_{\mathtt{s}}  Trust(\phi_{m}^{B})$$
%i.e. any formula in $\Gamma^{A}$ such that it satisfies dependencies for our conflicting package. This problem is equivalent to

%\begin{theorem}
%	$\phi_{i}^{A}\vdash_{\mathtt{s}}  Write(\phi_{m}^{B})$ iff $(\phi_{i}^{A}<\phi_{m}^{B}) \in\Gamma^{B}$.
%\end{theorem}






\begin{theorem}(\textbf{Mistrusted Uninstall})
	Given a package $\phi^{B}_{m}$ to be installed under profile $\Gamma^{A}$, a package $\phi^{A}_{i}$ is mistrusted in $\Gamma^{A}$ iff 
	\begin{enumerate}
	\item $\phi^{A}_{i}\leq \phi^{A}_{j}$
	\item $\phi^{A}_{j}< Read(\phi^{B}_{m})\rightarrow \bot$ and
	\item $\phi^{A}_{i}\nless \phi^{B}_{m}$.
	\end{enumerate}
	
	%$\phi_{i}^{A}\leq \neg \phi^{B}_{m}$.
	%$\phi_{i}^{A}\leq \neg \phi^{B}_{m}$.
\end{theorem}

\begin{proof}
The first condition is required by Lemma \ref{th:gen3.0} to include all the dependencies in the maximally mistrusted set. The second condition holds from Lemma \ref{th:gen3}. Finally, the third condition holds by contradiction: if $\phi^{A}_{i}< \phi^{B}_{m}$, then $\phi^{A}_{i}\vdash_{\mathtt{s}}  \phi^{B}_{m}$ by Dependency Insertion; it follows by Weakening that $\phi^{A}_{i}; \phi^{B}_{m}: profile$ and hence $\phi^{B}\vdash_{\mathtt{s}}  Trust (\phi^{A}_{i})$.
\end{proof}


This last result identifies packages to be removed as those that are in maximally mistrusted set and do not satisfy any dependency for the package to be installed under the current profile.



\section{An Example}\label{sec:example}

Consider the following scenario. A user on a Debian based system has the following installation profile:



$$
\Gamma^{m-f-nf}
\left\{
\begin{array}{l}
\Gamma^{main}=\{\phi^{m}_{1},\phi^{m}_{2}\}\\
\Gamma^{free}=\{\psi^{f}_{1}\}\\
\Gamma^{nonfree}=\{\xi^{nf}_{1}\}\\
\end{array}
\right\}
$$

with the following dependencies

$$
\Gamma^{m-f-nf}
\left\{
\begin{array}{l}
\phi^{m}_{1}<\psi^{f}_{1}\\
\phi^{m}_{2}<\psi^{f}_{1}\\
\psi^{f}_{1}<\xi^{nf}_{1}\\
\end{array}
\right\}
$$
Assume the user distrusts a package $\psi^{f}_{n}$, e.g. because it is considered harmful or unsecure. The Distrusted Uninstall Problem asks which packages can be further installed in $\Gamma^{m-f-nf}$ without installing $\psi^{f}_{n}$.  Consider now a package $\psi^{f}_{2}\ngtr \psi^{f}_{n}$, then the following derivation holds:


\begin{prooftree}
		%\noline
		
		\AxiomC{D}
						\UnaryInfC{$\Gamma^{m-f-nf}\vdash_{\mathtt{s}}  \neg Trust(\psi^{f}_{n})$}		
					\AxiomC{D'}
				
		\UnaryInfC{$\Gamma^{m-f-nf}\vdash_{\mathtt{s}}  Read(\psi^{f}_{2})$}
		\AxiomC{$\psi^{f}_{n}\nless \psi^{f}_{2}$}
	%	\AxiomC{$\Gamma^{m-f-nf}; \psi^{f}_{2}\vdash_{\mathtt{s}}  wf$}		
		\RightLabel{}
%		\TrinaryInfC{$\Gamma^{m-f-nf}; \psi^{f}_{2}\vdash_{\mathtt{s}}  wf$}
			\TrinaryInfC{$\Gamma^{m-f-nf}\vdash_{\mathtt{s}}  Write(\psi^{f}_{2})$}
	\end{prooftree}
In other words the flagging of $\psi^{f}_{n}$ as distrustful does not impede the installation of a package $\psi^{f}_{2}$ if the latter does not depend on the former.

Assume moreover that the user wishes to install an additional package $\xi^{nf}_{2}>\phi^{m}_{1}$, but such that  $\phi^{m}_{2}\vdash_{\mathtt{s}}  Read(\xi^{nf}_{2})\rightarrow \bot$: in other words, $\xi^{nf}_{2}$ depends from $\phi^{m}_{1}$, but is in conflict with $\phi^{m}_{1}$ (which is possible, given the latter does not depend on $\phi^{m}_{1}$). Then assuming a package $\psi^{f}_{2}$ replacing the functionalities of $\phi^{m}_{2}$,  the following derivation holds:


 
\begin{prooftree}
		%\noline
		
		\AxiomC{$\phi^{m}_{2}\vdash_{\mathtt{s}}  Read(\xi^{nf}_{2})\rightarrow \bot$}
		\AxiomC{$\phi^{m}_{2}<\psi^{f}_{1}$}
						\BinaryInfC{$\Gamma^{m-f-nf}\setminus \{\phi^{m}_{2}<\psi^{f}_{1}\}; \xi^{nf}_{2}\vdash_{\mathtt{s}}  \neg Trust(\phi^{m}_{2}<\psi^{f}_{1})$}		
						\AxiomC{$\psi^{f}_{2};\xi^{nf}_{2}: profile$}
				
		\BinaryInfC{$\Gamma^{m-f-nf}\setminus \{\phi^{m}_{2}<\psi^{f}_{1}\}; \xi^{nf}_{2}\vdash_{\mathtt{s}}  Write(\psi^{f}_{2})$}
	\end{prooftree}
In other words the installation of $\xi^{nf}_{2}$ requires removing $\phi^{m}_{2}<\psi^{f}_{1}$ and it is compatible with the installation of $\psi^{f}_{2}$.


%\section{The \texttt{(un)SecureNDC} Coq Library}



%\section{References}
%Generated by bibtex from your ~.bib file.  Run latex,
%then bibtex, then latex twice (to resolve references)
%to create the ~.bbl file.  Insert that ~.bbl file into
%the .tex source file and comment out
%the command \texttt{{\char'134}thebibliography}.
% This next section command marks the start of
% Appendix B, and does not continue the present hierarchy
%\section{More Help for the Hardy}
%The sig-alternate.cls file itself is chock-full of succinct
%and helpful comments.  If you consider yourself a moderately
%experienced to expert user of \LaTeX, you may find reading
%it useful but please remember not to change it.
%\balancecolumns % GM June 2007
% That's all folks!

\section{Conclusions}

In this paper we have formulated two variants to the Uninstall Problem. Each relies on a different semantic qualification of untrusted packages required to be removed or prevented from installation in a given installation profile, in order to preserve consistency. 

Our approach is grounded on the logic \texttt{(un)SecureND}, including an explicit $trust$ function on formulas to guarantee consistency check at each retrieval step (after a $read$ function), before installation rights are granted for a package (by a $write$ function). The fragment of the language presented in this paper allows to express negation over trust, thereby expressing a dis-installation requirement. Different pairs of introduction/elimination rules determine the selection of one of tow resolution strategies: one flags a package external to the installation profile as distrusted and hence as not installable; the other identifies already installed packages to be removed. The selection takes care to identify and remove all required dependencies. We have illustrated the working protocol through an easy example. 

Validation of the system is obtained by implementation of the \texttt{(un)SecureND} calculus as a large inductive type in the Coq proof assistant. The development is available at \url{https://github.com/gprimiero/SecureNDC}. It makes it possible to express and prove the lemmas and theorems from sections~\ref{sec:distrusted} and~\ref{sec:mistrusted}.

A characteristic of the logic \texttt{(un)SecureND} is its substructural nature, which in future work can be exploited to investigate cases of strengthened and limited resource redundancy for fault tolerance and source shuffling for security. Other applications of negative trust can be investigated to distinguish between malevolent and simply unsuccessful sources.



\bibliographystyle{plain}
\bibliography{unsecureNDC}
\end{document}
