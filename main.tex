\documentclass[compsoc, conference, letterpaper, 10pt, times]{IEEEtran}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
% \usepackage{amsart}
\usepackage{bussproofs}
\usepackage{url}

\newtheorem{definition}{Definition}
%\newtheorem{proposition}{Proposition}
%\newtheorem{thesis}{Thesis}
\newtheorem{theorem}{Theorem}
%\newtheorem{corollary}{Corollary}
%\newtheorem{lemma}{Lemma}

\begin{document}
%opening
\title{A Proof-theoretic Trust and Reputation Model for VANET}
%\author{Giuseppe Primiero}
%\institute{Department of Computer Science\\Middlesex University London\\United Kingdom}


\author{\IEEEauthorblockN{Giuseppe Primiero, Franco Raimondi, Taolue Chen, Rajagopal Nagarajan}
	\IEEEauthorblockA{Department of Computer Science,\\
		Middlesex University London,\\
		United Kingdom\\
		Email: G.Primiero|F.Raimondi|T.Chen|R.Nagarajan@mdx.ac.uk}}


\maketitle

\begin{abstract}
Vehicle Ad Hoc Networks (VANETs) are becoming an important part of intelligent transportation systems. In this context, security requirements need to rely on a combination of agents' reputation and trust relations over the messaging infrastructure, in order to maintain a dynamic and safe behaviour evaluation. Formal correctness, resolution of contradictions and proven safety of transitive operations within the infrastructure remain currently unexplored, with potentially disastrous effects. In this paper we provide a proof-theoretic  interpretation of such a reputation and trust model for VANET, which allows for a formal verification through translation into the Coq proof assistant, and which guarantees consistency of the messaging protocol and security of transitive transmissions.
\end{abstract}


\section{Introduction}\label{sec:intro}

Vehicle Ad Hoc Networks (VANETs) consist of vehicles and roadside units networks created to enhance transportation systems through V2V and V2I communications. Due to their distributed and dynamic nature, such networks are open to several types of threats, including false message propagation. Trust and reputation are among the  most used concepta to ensure integrity, reliability and safety of services. Several methods have been implemented, see \cite{Soleymani2015} for a recent overview. Trust models in VANETs differ in accordance to the main object of the model: entity-centric \cite{5641621, GomezMarmol:2012:TTR:2160992.2161100}, data-centric \cite{conf/infocom/RayaPGH08, Lo2009} and combined \cite{Wei2012}. Among the models that combine trust and reputation, \cite{glenford} gives an analysis that accounts for reputation as a characteristic of message forwarding, as well as vehicles, drivers and other agents: here reputation is therefore based on a descriptive ontology of the model and is used to provide feedback in the system. An overview of the issues related to the trust in fixed and mobile ad hoc networks is given in \cite{DBLP:conf/vtc/WexBHLD08}, while other approaches for trustworthiness and reputation in ad hoc mobile networks are presented, for example, in \cite{DBLP:conf/um/FinnsonZTMC12, DBLP:journals/ijaisc/ChaurasiaTV15}.

In most of these models, the analysis relies on simulations for an evaluation of efficacy. Yet, such simulations cannot guarantee free of unpredictable and unsafe behaviours. Since VANETs are meant to include safety and emergency messages, more reliable methods are essential. The only method to produce exhaustive safety control is through formal verification, but unfortunately none of the current trust and reputation models seem to have focused on a formal correctness requirement to ensure that the protocols are checkable. The only formal analysis available is in \cite{DBLP:conf/vtc/KonurF11} for a congestion control protocol using the model checking technique to investigate its correctness and effectiveness, but it does not focus explicitly on trust or reputation. Other formal verification techniques like theorem proving seem to have been ignored so far. Moreover, an additional problem, i.e.,  ensuring that safety is preserved over transitive operations, remains unexplored. 

The present paper provides a solution to both problems mentioned above. In Section \ref{sec:logic} we formulate a proof-theoretic translation of the trust and reputation model for VANET given in \cite{glenford} in an extension of the natural deduction calculus \texttt{(un)SecureND} from \cite{DBLP:conf/ifiptm/Primiero16}. The aim is, first of all, to show that the trust properties instantiated through our calculus faithfully reflect those in a VANET network; accordingly, we show how non-trustworthy interactions can be proven to be such through a proof-checking method. On a higher level, the model offered by \texttt{(un)SecureND} has been proven formally correct through its translation to a Coq library. As such, the present translation guarantees a similar property for the whole VANET model. Thanks to the structural properties of our calculus, we show how transitive message passing operations, in the form of instances of a cut rule, are guaranteed safe via applying a normalization result. In Section \ref{sec:opportunistic} we illustrate protocols for handshaking, recipient selection and message passing based on reputation. In Section \ref{sec:reputation} we give a reputation model based on an evaluation of feedback messages parametrised, in view of a temporal measure and a ranking of the relevant service characteristic of the message.


%\section{Related Work}\label{sec:related}


\section{\texttt{(un)SecureND}}\label{sec:logic}

$\mathtt{(un)SecureND}$ is a natural deduction calculus defining trust, mistrust and distrust protocols introduced in \cite{primiero_secureND} for the positive fragment and in \cite{DBLP:conf/ifiptm/Primiero16} for the negation complete extension. Here we provide  a slightly modified version adapted for a VANET network. In particular, the present version introduces: contexts as sets of sets; formulas with multiple indices to account for service and message numbers; ranking on service characteristics. We start with introducing the language of our logic:

\begin{definition}[Syntax of $\mathtt{(un)SecureND}$]\label{def:syntax} %The syntax  is defined by the following alphabet:
	%
	\begin{displaymath}
	\begin{array}{l}
	\mathcal{A}^{\prec}:= \{\mathcal{V, R}\}\\
	\mathcal{V}:= \{v_{1}\prec \ldots \prec v_{n}\}\\
	\mathcal{R}:= \{rsu_{1}\prec\ldots \prec rsu_{n}\}\\
	\mathcal{S}:= \{S_1, \dots, S_{n}\}\\  %\sim\in \{<,\leq, =, \geq, >\}
	\mathcal{C}:= \{C_{1}\leq \dots \leq C_{n}\}\\  %\sim\in \{<,\leq, =, \geq, >\}
	\phi^{\mathcal{A}}_{S_{i}, C_{j}}:= a^{\mathcal{A}}_{S_{i},C_{j}}\mid \neg \phi^{\mathcal{A}}_{i,j}\mid \phi^{\mathcal{A}}_{i,j}\rightarrow \phi^{\mathcal{A}}_{k,l}\mid \phi^{\mathcal{A}}_{i,j}\wedge \phi^{\mathcal{A}}_{k,l}\\
	\qquad \qquad \mid \phi^{\mathcal{A}}_{i,j}\vee \phi^{\mathcal{A}}_{k,l} \mid \bot\\
	mode:= Read(\mathcal{M}^{\mathcal{A}})\mid Write(\mathcal{M}^{\mathcal{A}})\mid Trust(\mathcal{M}^{\mathcal{A}})\\
	RES:= \mathcal{M}^{\mathcal{A}}\mid mode\mid \neg RES\\
	\Gamma^{\mathcal{A}}:= 
	%\{\{\phi^{\mathcal{A}}_{i,j}, \dots, \phi^{\mathcal{A}}_{i,k}\}, \dots, \{\phi^{\mathcal{A}}_{j,l}, \dots, \phi^{\mathcal{A}}_{j,m}\}\}
	\phi^{\mathcal{A}}_{i,j} \mid \phi^{\mathcal{A}}_{i,j} < \phi^{\mathcal{A}}_{k,l} \mid \Gamma^{\mathcal{A}}; \phi^{\mathcal{A}}_{i,j}
	%\{ \phi^{S}_{i}< \dots < \phi^{S}_{n}\}. %\Gamma^{**}:=\{\psi^{**}_{1}, \dots, \psi^{**}_{n}\}\\
	
	\end{array}
	\end{displaymath}
\end{definition}
%

%\subsection{Services, Messaging and Protocols}
$\mathcal{A}$ is the set of agents issuing messages and including vehicles $\mathcal{V}$ and roadside units (RSUs) $\mathcal{R}$. Below we will focus in particular on V2V communication, without loss of generality. $\mathcal{S}$ and $\mathcal{C}$ denote sets of services and their characteristics, respectively. Messages are boolean formulae, closed under connectives and including $\bot$ to express conflicts. Messages are signed by agents generating them and by service and characteristic identifiers, which are of the form $\phi^{v_{i}}_{S_{k},C_{j}}$, which intuitively expresses a  message $\phi$ about service $S_k$ and characteristic $C_j$,  generated by vehicle $v_{i}$. When required, we will refer to a set of messages about service $S_{k}$ and characteristic $C_{k}$ from agent $v_{i}$ as $\mathcal{M}^{v_{i}}_{S_{i}, C_{k}}$; this notation can be further generalised to a whole set of agents $\{v_{i}, \dots, v_{k}\} \subseteq  \mathcal{A}$. We assume here and throughout that characteristics $\mathcal{C}$ of services are given as posets and their ordering is used to order messages below in Definition \ref{def:dependencypackages}. 
To simplify notation, a message $\phi^{v_{i}}_{S_{k},C_{j}}$ is usually abbreviated as $\phi^{v_{i}}_{{k},{j}}$. $mode$ is a variable for reading, writing and trusting messages, closed under negation. An agent profile $\Gamma^{\mathcal{A}}$ is the current list of all messages collected by the agent either from other agents or from various available sensors and other networks. For the present purposes, the latter ones will be indexed at their first vehicle or RSU collecting it, so as not to add networks as separate agents.


\begin{definition}[Formulae]
A formula $\Gamma^{v}_{i} \vdash_{\mathtt{s}} \phi^{v_{j}}_{i,k}$ states that a message $\phi$ about service $i$ and characteristic $k$ signed from agent $v_{j}$  is validly accessed at step $\mathtt{s}\geq 0$ under the profile of agent $v_{i}$.
\end{definition}

\begin{definition}[Validity]
A formula $\vdash_{\mathtt{s}} \phi^{v_{j}}_{i,k}$ says that a message $\phi$  about service $i$ and characteristic $k$ signed from agent $v_{j}$ holds for \textit{any} agent's profile at step $\mathtt{s}$.
\end{definition}

Messages satisfy a ranking based on characteristics:

\begin{definition}\label{def:dependencypackages}
An order between messages $\phi^{v_{j}}_{i,k}<\phi^{v_{j}}_{i,l}$ holds if $C_{k}\leq C_{l} \in S_{i}$ for an agent $v_{j}$.
%
%says that for agent $v_{j}$ the characteristic $k$ of service $i$ is more important or essential than characteristic $l$ for the same service; then $\phi^{v_{j}}_{i,k} \vdash_{\mathtt{s}}  \phi^{v_{j}}_{i,l}$.
\end{definition}

The order relation between service characteristics induces therefore validity under profile: if a characteristic $i$ is essential to another one $l$ with respect to a service $i$ for an agent $v_{j}$, then that agent will be required to obtain a value for  $i$ in order to validly access a value for $l$. 

%This order relation between service characteristics can then be lifted at the level of services. A partial order relation $\leq$ over $\mathcal{S}\times \mathcal{S}$ intuitively expresses that an order is satisfied across services: 
%$S\leq S'$ means that repository $S$ contains a package that satisfies a dependency for a package in $S'$
%
%\begin{definition}\label{def:orderrepos}
%	$S_{i}\leq S_{j}$  iff $\exists \phi^{v_{j}}_{i,k},\phi^{v_{j}}_{j,l}\ s.t.\ \phi^{v_{j}}_{i,k}<\phi^{v_{j}}_{j,l}$.
%\end{definition}
%By the first clause in Definition \ref{def:orderrepos}, 
%$S_{i}< S_{j}$ means therefore that a service $S_{i}$ is essential for a service $S_{j}$ if there is a message concerning a characteristic of the latter which requires a message about a characteristic of the former. 
%The condition for $\leq$ is satisfied by a dependency relation $\phi_{i}^{A}<\phi_{j}^{A}$ between two packages in the same repository $A$. 
%The partial order allows for branching in the hierarchy, so that e.g. $S_{i}<S_{j}<S_{k}$ and $S_{i}<S_{j}<S_{l}$,  i.e. packages in $S_{k},S_{l}$  both require service $S_{j}$ and transitively $S_{i}$, but they have no requirement from each other. 
%By the second clause in Definition \ref{def:orderrepos}, our order relation abstracts from the issue of reciprocal dependencies. As noted in~\cite{DBLP:journals/eceasst/Boender11}, two packages that mutually depend on each other will either be installed together, or not installed at all. They can therefore be considered as a single package for dependency resolution purposes. 


A valid agent profile meets all the requirements and conflicts clauses of all service messages that the user collects.
%Context $\Gamma^{A}$ formalises a list of formulae describing an installation profile with packages from repository $A$, ordered by the dependency relation holding between relevant packages in $A$. 
%An installation profile can be extended by packages obtained by the same repository, denoted by $\Gamma^{A}, \phi^{A}$. 
Rules from Figure \ref{fig:system0} define agent's profile construction from service messages requirements. By Empty Profile, a user profile can be empty (base case); by Message Insertion, the elements in an installation profile are messages; by Requirement Insertion, a profile can be extended by satisfied service requirements; by Profile Extension, if a message holds in an empty profile, it can be added to an existing profile. 
%Notice that unnecessary packages from any repository can still be added: this is possible for packages without dependencies through the Profile Extension rule, but more in general by an application of the Weakening Rule (see Figure \ref{fig:system3}). The result of such a profile extension is denoted by $\Gamma^{A}; \phi^{B}$ and $\Gamma^{A}; \Gamma^{B}$. It is worth noting that Weakening will preserve profile consistency as it requires additionally an instance fo the $trust$ rule (see Figure \ref{fig:system2}). 

\begin{figure*}[h]
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{Empty Profile}
		\UnaryInfC{$\{\}: profile$}
		\DisplayProof
		\qquad
		\AxiomC{$\phi^{v_{j}}_{i,k} \!:\!\mathcal{M}^{v_{j}}$}
		\RightLabel{Message Insertion}
		\UnaryInfC{$ \phi^{v_{j}}_{i,k} \!:\!profile$}
	\end{prooftree}
	
	
	\begin{prooftree}
	   	\AxiomC{$\Gamma^{v_{j}}, \phi^{v_{j}}_{i,k}: profile$}
		\AxiomC{$\Gamma^{v_{j}}, \phi^{v_{j}}_{i,k}\vdash_{\mathtt{s}}  \psi^{v_{k}}_{i,l}$}
		\RightLabel{Requirement Insertion}
		\BinaryInfC{$\Gamma^{v_{j}}, \phi^{v_{j}}_{i,k}< \psi^{v_{k}}_{i,l} \!:\!profile$}
		%\end{prooftree}
	\end{prooftree}


\begin{prooftree}
			\AxiomC{$\Gamma^{v_{i}}: profile$}
			\AxiomC{$\vdash_{\mathtt{s}}  \psi^{v_{k}}_{j,l}$}
			\RightLabel{Profile Extension}
			\BinaryInfC{$\Gamma^{v_{i}};\psi^{v_{k}}_{j,l} \!:\!profile$}
		\end{prooftree}
	
	
	\caption{The System \texttt{(un)SecureND}: Profile Construction Rules}\label{fig:system0}
\end{figure*}




\subsection{Rules for message construction}

The operational rules in Figure \ref{fig:system1} formulate compositionality of messages. The rule $Atom$ establishes valid content within a user profile and across other profiles with satisfied requirements. $\bot$ formulates implication of access to contradictory messages, in which case the profile must be consistent with the negated access. $\wedge$-I allows message composition from distinct profiles; by $\wedge$-E, each composing message can be obtained from the combined profiles. $\vee$-I says that a combined profile can access any message produced from each of the composing profiles; by the elimination $\vee$-E, each message consistently inferred by each individual profile can also be executed under the extended profile. $\rightarrow$-Introduction expresses inference of a message from a combined profile as inference between messages (Deduction Theorem); its elimination $\rightarrow$-E allows to recover such inference as profile extension (Modus Ponens).

\begin{figure*}[t]
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}};\Gamma^{v_{j}}: profile$}
		\RightLabel{Atom, for any $\psi^{v_{j}}_{i,l}\in \Gamma^{v_{j}}$}
		\UnaryInfC{$\Gamma^{v_{i}};\Gamma^{v_{j}}\vdash_{\mathtt{s}}  \psi^{v_{j}}_{i,l}$}
		%\end{prooftree}
		\DisplayProof
		\qquad
		%
		%\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}  RES \rightarrow \bot$}
		\RightLabel{$\bot$}
		\UnaryInfC{$\Gamma^{v_{i}}\vdash_{\mathtt{s+1}}  \neg RES$}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l}$}
		\AxiomC{$\Gamma^{v_{j}} \vdash_{\mathtt{s'}}  \psi^{v_{j}}_{i,m}$}
		\RightLabel{$\wedge$-I}
		\BinaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{max(s,s')+1}}  \phi^{v_{i}}_{i,l} \wedge \psi^{v_{j}}_{i,m}$}
		\DisplayProof
		\qquad
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l} \wedge \psi^{v_{j}}_{i,m}$}
		\RightLabel{$\wedge$-E}
		\UnaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s+1}}  \phi/\psi^{v_{i/j}}_{i,l/m}$}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s}}  \phi^{v_{i/j}}_{i,l/m}$}
		\RightLabel{$\vee$-I}
		\UnaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s+1}}  \phi^{v_{i}}_{i,l} \vee \psi^{v_{j}}_{i,m}$}
		\DisplayProof
		\quad
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l} \vee \psi^{v_{j}}_{i,m}$}
		\AxiomC{$\psi^{v_{i/j}}_{i,l/m} \vdash_{\mathtt{s'}}  \xi^{v_{i/j}}_{k,n}$}
		\RightLabel{$\vee$-E}
		\BinaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{max(s,s')+1}}  \xi^{v_{i/j}}_{k,n}$}
	\end{prooftree}
	
	
	%	with $I\in \{A,B\}, i \in\{1,2\}$ in the above rules.
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}};\phi^{v_{i}}_{i,l}\vdash_{\mathtt{s}}  \psi^{v_{j}}_{i,m}$}
		\RightLabel{$\rightarrow$-I}
		\UnaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s+1}}  \phi^{v_{i}}_{i,l} \rightarrow \psi^{v_{j}}_{i,m}$}
		\DisplayProof
		\qquad
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l} \rightarrow \psi^{v_{j}}_{i,m}$}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s'}}  \phi^{v_{i}}_{i,l}  $}
		\RightLabel{$\rightarrow$-E}
		\BinaryInfC{$\Gamma^{v_{i}};\phi^{v_{i}}_{i,l}\vdash_{\mathtt{max(s,s')+1}}  \psi^{v_{j}}_{i,m}$}
	\end{prooftree}
	
	
	
	\caption{The System \texttt{(un)SecureND}: Operational Rules}\label{fig:system1}
\end{figure*}



\subsection{Access Rules}

In Figure \ref{fig:system2} we present the access rules on messages. These allow an agent's profile to act on messages from a distinct agent. $\neg$-distribution expresses profile consistency: if an agent's profile does not allow inferring a message $\phi_{i,j}$, then it allows inferring any other message whose requirements do not include $\phi_{i,j}$. $\mathit{read}$ says that from any consistent profile a message can be read provided its requirements are satisfied (if any). $\mathit{trust}$ works as an elimination rule for $read$: it says that if a message is received and it preserves profile consistency, then it can be trusted. $\mathit{write}$ works as an elimination rule for $trust$: it says that a readable and trustable message can be broadcast. $\mathit{exec}$ says that every message consistently received by a profile is valid in it. The rule MTrust-I says that currently held message conflicting with a newly arrived message are mistrusted, i.e. removed from the current profile until none of its consequences are included; the corresponding MTrust-E elimination allows to trust any message consistent with the conflict resolution by removal of the mistrusted message in the user profile, including any required dependency, as expressed by the side condition that requires checking with any other agent who has higher reputation than the sender of the original message. The side condition can be modified at will, e.g., to design a protocol that will restore previous information if a sufficient number of other agents with higher reputation support it. \textit{mistrust} is a flag for facilitating removal of messages present in the user profile conflicting in view of incoming new information. 




%\Gamma^{v_{i}};\Gamma^{v_{j}}\vdash_{\mathtt{s}}  \psi^{v_{j}}_{i,l}
\begin{figure*}[t]
	\centering
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{s}}  \neg mode(\psi^{v_{j}}_{i,l})$}
		\RightLabel{$\neg$-distribution}
		\UnaryInfC{$\Gamma^{v_{i}}\vdash_{\mathtt{s+1}}  mode(\neg \psi^{v_{j}}_{i,l})$}
		\DisplayProof
		\qquad
		%
		\AxiomC{}
		\RightLabel{$\mathit{read}$}
		\UnaryInfC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})$}
		\end{prooftree}
		
       \begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})$}
		\AxiomC{$\Gamma^{v_{i}};\psi^{v_{j}}_{i,l} : profile$}
		\RightLabel{$\mathit{trust}$}
		\BinaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s+1}}   Trust(\psi^{v_{j}}_{i,l} ) $}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})$}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s'}}   Trust(\psi^{v_{j}}_{i,l} ) $}
		\RightLabel{$\mathit{write}$}
		\BinaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s'+1}}   Write(\psi^{v_{j}}_{i,l} ) $}
		\DisplayProof
		\qquad
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   Write(\psi^{v_{j}}_{i,l} ) $}
		\RightLabel{$\mathit{exec}$}
		\UnaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s+1}}   \psi^{v_{j}}_{i,l}  $}
	\end{prooftree}
	
%	\begin{prooftree}
%%		\AxiomC{$\Gamma^{A}\vdash_{\mathtt{s}}   wf$}
%		\AxiomC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})\rightarrow \bot $}
%		\RightLabel{DTrust-I}
%		\UnaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   \neg Trust(\psi^{v_{j}}_{i,l} ) $}
%		\end{prooftree}
%		%\DisplayProof
%		%\qquad	
%		
%		\begin{prooftree}
%		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   \neg Trust(\psi^{v_{j}}_{i,l} ) $}
%		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   \neg Trust(\psi^{v_{j}}_{i,l}) \rightarrow \xi^{v_{k}}_{i,m}$}
%		\RightLabel{DTrust-E}
%		\BinaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   Write(\xi^{v_{k}}_{i,m}) $}
%	\end{prooftree}
%	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   Read(\psi^{v_{j}}_{i,l})\rightarrow \bot $}
		\AxiomC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\} : profile$}
%		%\vdash_{\mathtt{s}}   wf, $\forall \phi^{A}_{j}\vdash_{\mathtt{s}}  Read(\psi^{B}_{i})\rightarrow \bot $}
		\RightLabel{MTrust-I}
		\BinaryInfC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\} \vdash_{\mathtt{s+1}}   \neg Trust(\neg \psi^{v_{i}}_{i,l})$}
	\end{prooftree}
%	
%
%	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\} \vdash_{\mathtt{s}}   \neg Trust(\neg \psi^{v_{i}}_{i,l})$}
		\AxiomC{$\Gamma^{v_{k}}; \psi^{v_{j}}_{i,j} : profile$}
		\RightLabel{MTrust-E, $\forall v_{k}\prec v_{j}$}
		\BinaryInfC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\};\Gamma^{v_{k}}\vdash_{\mathtt{s+1}}  Trust(\psi^{v_{j}}_{i,l})$}
	\end{prooftree}
	\caption{The System \texttt{(un)SecureND}: Access Rules}\label{fig:system2}
\end{figure*}

%



%We can now offer a more general interpretation of the derivability relation $\vdash_{\mathtt{s}} $ as access and execution of some message under a given user profile:
%%
%\begin{definition}
%	A formula $\Gamma^{v_{i}} \vdash_{\mathtt{s}}  RES$ says that a message from some user $v_{k}$ is validly accessed ($mode(\phi^{v_{k}})$) and eventually inferred ($\phi^{v_{k}}$) within a user profile with messages held by user $v_{i}$ at step $\mathtt{s}$. 
%\end{definition}



\subsection{Structural Rules}

Structural rules hold with restrictions for $\mathtt{(un)SecureND}$, see Figure \ref{fig:system3}. As a result, the system qualifies as substructural, see for instance \cite{restall}. Weakening is constrained by an instance of $trust$: it says that valid information is preserved under an agent's profile extension, assuming the latter is provably consistent and therefore no refresh is required. Contraction is constrained by preservation of ordering: it says that removing identical messages from  an agent's profile is admissible, with the constraint that the copy from the agent with higher reputation is preserved. Exchange is constrained by dependency: it says that reorder of messages is admissible if there is no involved dependency between them. Finally, the Cut rule expresses validity under profile extension: if a message $\phi_{i,j}$ is validly for agent $v_{i}$ and after messaging it to $v_{j}$ the latter can infer $\phi_{i,k}$, then $v_{i}$ can infer $\phi_{i,k}$ by setting a message protocol with $v_{j}$.


\begin{figure*}[t]
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,j}$}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{s'}}  Trust(\phi^{v_{j}}_{j,k})$}
		\RightLabel{Weakening}  
		\BinaryInfC{$\Gamma^{v_{i}}; \phi^{v_{j}}_{j,k}\vdash_{\mathtt{max(s,s'}+1)}  \phi^{v_{i}}_{i,j}$}
%	\end{prooftree}
\DisplayProof
%	
%		\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \phi^{v_{j}}_{j,k}; \phi^{v_{k}}_{j,k}\vdash_{\mathtt{s}}  \psi^{v_{i}}_{i,j}$}
		\AxiomC{$v_{j} \prec v_{k}$}
		\RightLabel{Contraction}
		\BinaryInfC{$\Gamma^{v_{i}}; \phi^{v_{j}}_{j,k}\vdash_{\mathtt{s+1}}  \psi^{v_{i}}_{i,j}$}
	\end{prooftree}

	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \phi^{v_{i}}_{i,j}; \phi^{v_{i}}_{i,k}\vdash_{\mathtt{s}}  \psi^{v_{i}}_{i,j}$}
		\AxiomC{$\phi^{v_{i}}_{i,j}\nless \phi^{v_{i}}_{i,k}$}
		\RightLabel{Profile Exchange}
		\BinaryInfC{$\Gamma^{v_{i}}; \phi^{v_{i}}_{i,k}; \phi^{v_{i}}_{i,j}\vdash_{\mathtt{s+1}}  \psi^{v_{i}}_{i,j}$}
	\end{prooftree}
%\DisplayProof

	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,j}$}
		\AxiomC{$\Gamma^{v_{j}}, \phi^{v_{i}}_{i,j}\vdash_{\mathtt{s'}}   \phi^{v_{j}}_{i,k}$ }
		\RightLabel{Cut}
		\BinaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}\vdash_{\mathtt{max(s,s')+1}}   \phi^{v_{j}}_{i,k}$}
	\end{prooftree}
	\caption{The System \texttt{(un)SecureND}: Structural Rules}\label{fig:system3}
\end{figure*}

%The cut rule justifies the following result:

\begin{theorem}[Normalization]
Any $\mathtt{(un)SecureND}$ derivation with an occurrence $c$ of the $Cut$ rule can be transformed into another derivation with the same end sequent without $c$ using only trust.
\end{theorem}

\begin{proof}
	By induction on the derivation $D$ which is the redex of the cut-elimination. Assuming $c$ is the only Cut rule and it is the last inference rule of the redex, the derivation $D^\prime$ which is the contractum of the cut-elimination contains a descendent of the cut obtained by an instance of Weakening under trust. Because the formula obtained by the cut is, by hypothesis, derivable from the weaker protocol, it will also be derivable from the weaker and the stronger protocol together. When $c$ is not the last inference rule of the redex, then the descendent of the cut will admit all similar Weakenings preserving the one occurring in the cut; those imports by Weakening will occur also in the contractum of the cut rule and can be traced back up to the one formulation of the import that occurs in the cut rule.
\end{proof}

Normalization justifies a safety property of our trust and reputation model over transitive transmissions: for each vehicle $v_{i}, v_{j}, v_{k}$, if $v_{k}$ holds information $\phi_{i,j}$ and this information is passed to $v_{j}$, then every valid message derived from $\phi_{i,j}$ by $v_{k}$ can be inferred by $v_{j}$ assuming the consistency (by trust) of its profile with that of $v_{k}$; similarly now, $v_{j}$ can pass $\phi_{i,j}$ to $v_{i}$, and the latter can infer from there, assuming its profile is consistent with those of $v_{j}, v_{k}$.



\section{Opportunistic Forwarding}\label{sec:opportunistic}

%\subsection{Handshaking Protocol}

In Figure \ref{fig:handshake} we present an example derivation mimicking an handshaking protocol. Here Service 1 identifies the set of messages for this protocol. By Hello Message, a user $v_{i}$ with a well-defined profile with a `hello' message in its recognition service sends the message to the network;   a user $v_{k}$ reading the message and assuming it preserves consistency (e.g. there is no instruction in its profile to ingore messages from $v_{i}$), accepts it and forwards it further, including a `hello' back to $v_{i}$.



\begin{figure*}
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}:profile$}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{1}}  hello^{v_{i}}_{1,1}$}
		\RightLabel{Hello Message}
		\BinaryInfC{$\Gamma^{v_{i}}\vdash_{\mathtt{2}}  Write(hello^{v_{i}}_{1,1})$}
		\end{prooftree}

	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{1}}  Write(hello^{v_{i}}_{1,1})$}
		\AxiomC{$\Gamma^{v_{k}}\vdash_{\mathtt{2}}  Read(hello^{v_{i}}_{1,1})$}
				
		\AxiomC{$\Gamma^{v_{k}}; hello^{v_{i}}_{1,1}:profile$}
		\RightLabel{Response Message}
		\TrinaryInfC{$\Gamma^{v_{k}}; hello^{v_{i}}_{1,1}\vdash_{\mathtt{3}}  Write(hello^{v_{k}}_{1,1})$}
		\end{prooftree}


	\caption{The Handshaking Protocol}\label{fig:handshake}
\end{figure*}


%\subsection{Recipient Selection Protocol}

In Figure \ref{fig:selection}, we present an example derivation mimicking the recipient selection protocol. Here the idea is as follows: after $v_{i}$ broadcasts a `hello' message, $v_{k}, v_{j}$ both receive and accept the message; at this stage a recipient is selected on the basis of the reputation order between $v_{k}$ and $v_{j}$, so that a new profile is built out of $v_{i}$ and the higher of the two recipients, thus mimicking a communication channel.


\begin{figure*}
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{k}}; hello^{v_{i}}_{1,1}\vdash_{\mathtt{1}}  Write(hello^{v_{k}}_{1,1})$}
		\AxiomC{$\Gamma^{v_{j}}; hello^{v_{i}}_{1,1}\vdash_{\mathtt{2}}  Write(hello^{v_{j}}_{1,1})$}
		\AxiomC{$v_{k} \prec v_{j}$}
		\RightLabel{Recipient Selection}
		\TrinaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{k}}:profile$}
		\end{prooftree}

	\caption{The Handshaking Protocol}\label{fig:selection}
\end{figure*}


%\subsection{Message Passing Protocol}

In Figure \ref{fig:mp}, we present an example derivation mimicking the message passing protocol (without mistrust). Here Service 2 is some service of any kind. By the first premise in MP, the Handshaking Protocol is guaranteed terminating, including the Recipient Selection protocol if required; $v_{k}$ then reads a message issued by $v_{i}$, checks for validity in its own profile through an application of $trust$, and if this check is passed the message is forwarded.



\begin{figure*}
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{k}}:profile$}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{1}}  Write(m^{v_{i}}_{2,1})$}
		\RightLabel{MP}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{2}}  Read(m^{v_{i}}_{2,1})$}
		\AxiomC{$\Gamma^{v_{k}}; m^{v_{i}}_{2,1}: profile$}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{3}}  Trust(m^{v_{i}}_{2,1})$}
		\UnaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{4}}  Write(m^{v_{i}}_{2,1})$}
		\end{prooftree}

	\caption{The Message Passing Protocol}\label{fig:mp}
\end{figure*}




\section{Reputation Model}\label{sec:reputation}

In this section we illustrate the definition of the order relation $\prec$ to formalise the reputation model across agents. Higher reputation is modelled by feedback aggregation. Our system integrates the elements of the main feedback 6-tuple function from \cite{glenford}. In particular, time is mimicked directly by derivation steps; context is embedded by the user profile; service and characteristics are modelled by messages. To model the set of feedback that a given agent provides with respect to a given message related to a service and characteristic, we will have to collect all formulae following receiving a message:

\begin{definition}[Feedback Set]
The feedback set of agent $v_{j}$ for a message $\phi^{v_{i}}_{i,j}$, for all $v_{j}, v_{i} \in \mathcal{A}$ is the set of formulas $\psi^{v_{j}}_{i,k}$ such that they agree with $\phi^{v_{i}}_{i,j}$ for the service identifier $i$ and are obtained by a derivation construed by a $read$ rule followed by a $\rightarrow I$ rule, i.e.
%
\[
FS^{v_{j}}(\phi^{v_{i}}_{i,j})=\{ \psi^{v_{j}}_{i,k}\mid \Gamma^{v_{j}}
\vdash_{\mathtt{s}}  Read(\phi^{v_{i}}_{i,j})\rightarrow \psi^{v_{j}}_{i,k}  \}
\]
\end{definition}

By way of example, consider the following simple derivation, which induces $FS^{v_{k}}(m^{v_{i,j}}_{2,1})=\{m^{v_{k}}_{2,2}\}$: 

\begin{figure*}
\begin{footnotesize}

	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{k}}:profile$}
		\AxiomC{$\Gamma^{v_{j}}; \Gamma^{v_{k}}:profile$}
		\BinaryInfC{$\Gamma^{v_{i}};\Gamma^{v_{j}}; \Gamma^{v_{k}}:profile$}
		
		\AxiomC{$\Gamma^{v_{k}}\vdash_{\mathtt{1}}  Write(m^{v_{i,j}}_{2,1})$}
%		\AxiomC{$\Gamma^{v_{k}}\vdash_{\mathtt{s}}  Write(m^{v_{j}}_{2,1})$}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{2}}  Read(m^{v_{i,j}}_{2,1})$}
		\AxiomC{$\Gamma^{v_{k}}; m^{v_{i,j}}_{2,1}: profile$}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{3}}  Trust(m^{v_{i,j}}_{2,1})$}
		\UnaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{4}}  Write(m^{v_{i,j}}_{2,1})$}
		\AxiomC{$\Gamma^{v_{k}}; m^{v_{i,j}}_{2,1}\vdash_{\mathtt{5}}  m^{v_{k}}_{2,2}$}
        \BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{6}}  m^{v_{i}}_{2,1} \rightarrow m^{v_{k}}_{2,2}$}
		\end{prooftree}
\end{footnotesize}


	\caption{An Example Feedback Set}\label{fig:ask}

\end{figure*}

Notice that, by construction, this set includes only feedback to received messages that are consistent with the current user's profile. 

\begin{definition}[Agent's Perception]
The perception of agent $v_{j}$ for a message $\phi^{v_{i}}_{i,j}$, for all $v_{j}, v_{i} \in \mathcal{A}$ is the sum of elements of the feedback set over that formula, weighted by the step of the derivation at which it is obtained: 

\[
AP^{v_{j}}(\phi^{v_{i}}_{i,j})=\sum_{FS^{v_{i}}(\phi^{v_{j}}_{i,k})}(\mathtt{s}(\psi^{v_{j}}_{i,k} \in FS^{v_{i}}(\phi^{v_{j}}_{i,k})))
%\mid \Gamma^{v_{j}}
%\vdash_{\mathtt{s}}  Read(\phi^{v_{i}}_{i,j})\rightarrow \psi^{v_{j}}_{i,k}  \}
\]

\end{definition}

Intuitively, the value of $\mathtt{s}$ at each step of each derivation leading to each formula in the feedback set of an agent to a given service and characteristic is summed up to provide a value that increases linearly to reflect a step value for a time function. The value of $AP^{v_{j}}(\phi^{v_{i}}_{i,j})$ will reflect the aggregation of all the feedback provided on each characteristics of a given service.  


We can now generalise to the set of all feedback on a characteristic for a given service, remembering that these are given in a preorder so that the position of the characteristic in that order is mapped into an integer:


\begin{definition}[Agent's Perception of Characteristic Set]
The perception of agent $v_{j}$ for a set of messages $\mathcal{M}^{\mathcal{A}}_{S_{i},C_{k}}$ from agents in $\mathcal{A}$ about characteristic $C_{k}$ of service $S_{i}$
is the sum of elements of the feedback set over the messages received about that service characteristic, weighted by the steps of the derivation at which it is obtained and further by the value $\mathtt{r}(C_{k})$ of the rank of characteristic $k$: 


\begin{displaymath}
\begin{array}{l}

AP^{v_{j}}(\mathcal{M}^{\mathcal{A}}_{S_{i}, C_{k}})=\\
\sum_{FS^{v_{i}}(\phi^{v_{j}}_{i,k}\dots \phi^{v_{n}}_{i,k})}
(1-\mathtt{r}(C_{k})(\mathtt{s}(\psi^{v_{j}}_{i,k} \in FS^{v_{i}}(\phi^{v_{j}}_{i,k}\dots \phi^{v_{n}}_{i,k}))))
\end{array}
\end{displaymath}

\end{definition}


Using the agent's perception of characteristic set, we can define the order of reputation with respect to services and characteristics, which establishes a higher position for the agent whose perception on the characteristics set for that Service is greater.

\begin{definition}[Reputation]
$\forall v_{i}, v_{j}\in \mathcal{V}, S_{i}\in \mathcal{S}, v_{i}\prec v_{j} \leftrightarrow AP^{v_{i}}(\mathcal{M}^{\mathcal{A}}_{S_{i}, C_{k}})>AP^{v_{j}}(\mathcal{M}^{\mathcal{A}}_{S_{i}, C_{k}})$.
\end{definition}

\section{Conclusions}

In this paper we have formulated a proof-theory for trust and reputation in VANETs. Our language is modelled on the logic \texttt{(un)SecureND}, including an explicit $trust$ function on formulas to guarantee consistency check at each retrieval step (after a $read$ function), before forwarding is granted for a package (by a $write$ function). Forwarding is modelled in an opportunistic fashion, selecting receivers on the basis of their reputation ranking. Trust on forwarding also guarantees correctness on transitive transmissions. Moreover, reputation is used to implement the resolution protocol for restoring information after removing previously stored data.
% Different pairs of introduction/elimination rules determine the selection of one of tow resolution strategies: one flags a package external to the installation profile as distrusted and hence as not installable; the other identifies already installed packages to be removed. The selection takes care to identify and remove all required dependencies. We have illustrated the working protocol through an easy example. 
Validation of the system is obtained by implementation of the \texttt{(un)SecureND} calculus as a large inductive type in the Coq proof assistant. The development is available at \url{https://github.com/gprimiero/SecureNDC}. 
%It makes it possible to express and prove the lemmas and theorems from sections~\ref{sec:distrusted} and~\ref{sec:mistrusted}.
A characteristic of the logic \texttt{(un)SecureND} is its substructural nature, which in future work can be exploited to investigate cases of strengthened and limited resource redundancy for fault tolerance and source shuffling for security. Other applications of negative trust can be investigated to distinguish between malevolent and simply unsuccessful sources.


\bibliographystyle{plain}
\bibliography{unsecureNDC}

\end{document}

