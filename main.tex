\documentclass[compsoc, conference, letterpaper, 10pt, times]{IEEEtran}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
% \usepackage{amsart}
\usepackage{bussproofs}
\usepackage{url}

\newtheorem{definition}{Definition}
%\newtheorem{proposition}{Proposition}
%\newtheorem{thesis}{Thesis}
\newtheorem{theorem}{Theorem}
%\newtheorem{corollary}{Corollary}
%\newtheorem{lemma}{Lemma}

\begin{document}
%opening
\title{A Proof-theoretic Trust and Reputation Model for VANET}
%\author{Giuseppe Primiero}
%\institute{Department of Computer Science\\Middlesex University London\\United Kingdom}


\author{\IEEEauthorblockN{Giuseppe Primiero, Franco Raimondi, Taolue Chen, Rajagopal Nagarajan}
	\IEEEauthorblockA{Department of Computer Science\\
		Middlesex University London\\
		United Kingdom\\
		Email: G.Primiero|F.Raimondi|T.Chen|R.Nagarajan@mdx.ac.uk}}


\maketitle

\begin{abstract}
Vehicle Ad Hoc Networks (VANETs) are becoming an important part of intelligent transportation systems. In this context, security requirements need to rely on a combination of agents' reputation and trust relations over the messaging infrastructure in order to maintain a dynamic and safe behaviour evaluation. Formal correctness, resolution of contradictions and proven safety of transitive operations within the infrastructure remain currently unaddressed, with potentially disastrous effects. In this paper we offer a proof-theoretical interpretation of such a reputation and trust model for VANET which allows for a formal verification through translation in the Coq proof assistant and which guarantees consistency of the messaging protocol and security of transitive transmissions.
\end{abstract}


\section{Introduction}\label{sec:intro}

Vehicle Ad Hoc Networks (VANETs) consist of vehicles and roadside units networks created to enhance transportation systems through V2V and V2I communications. Due to their distributed and dynamic nature, such networks are open to several types of threats, including false message propagation. Trust and reputation are among the concept most used to ensure integrity, reliability  and safety of services. Several methods have been implemented, see \cite{Soleymani2015} for a recent overview. Trust models in VANETs differ especially for the main object of the model: entity-centric \cite{5641621, GomezMarmol:2012:TTR:2160992.2161100}, data-centric \cite{conf/infocom/RayaPGH08, Lo2009} and combined \cite{Wei2012}. Among the models that combine trust and reputation, \cite{glenford} offers an analysis that accounts for reputation as a characteristic of message forwarding, vehicles, drivers and other agents as well: here reputation is therefore based on a descriptive ontology of the model and is used to feedback in the system. 

Unfortunately, none of the current models seem to have focused on a formal correctness requirement to ensure that derivability of messages passing protocol is checkable. Moreover, an additional problem seems to have been ignored, namely how to ensure that safety is preserved over transitive message passing operations. This paper provides a solution to both problems above. We formulate a proof-theoretic translation of the trust and reputation model for VANET offered in \cite{glenford} in an extension of the natural deduction calculus \texttt{(un)SecureND} from \cite{DBLP:conf/ifiptm/Primiero16}. The aim is, first of all, to show that the trust properties instantiated through our calculus faithfully reflect those in a VANET network; accordingly, we show how non-trustworthy interactions can be proven to be such through a proof-checking method. On a higher level, the model offered by \texttt{(un)SecureND} has been proven formally correct through its translation to a Coq library, and as such the present translation guarantees a similar property for the whole VANET model. Finally, thanks to the structural properties of our calculus, we consider a transitive messgae passign operation in the form of instances of a cut rule, whose normalization guarantees safety.


%\section{Related Work}\label{sec:related}


\section{\texttt{(un)SecureND}}\label{sec:logic}

$\mathtt{(un)SecureND}$ is a natural deduction calculus defining trust, mistrust and distrust protocols introduced in \cite{primiero_secureND} for the positive fragment  and in \cite{DBLP:conf/ifiptm/Primiero16} for the negation complete extension. We offer here a slightly modified version adapted for the VANET network. In particular, the present version introduces: contexts as sets of sets; formulas with multiple indices to account for service and message numbers; ranking on service characteristics. We start with introducing the language of our logic:

\begin{definition}[Syntax of $\mathtt{(un)SecureND}$]\label{def:syntax} %The syntax  is defined by the following alphabet:
	%
	\begin{displaymath}
	\begin{array}{l}
	\mathcal{A}^{\prec}:= \{\mathcal{V, R}\}\\
	\mathcal{V}:= \{v_{1}\prec \ldots \prec v_{n}\}\\
	\mathcal{R}:= \{rsu_{1}\ldots rsu_{n}\}\\
	\mathcal{S}:= \{S_1, \dots, S_{n}\}\\  %\sim\in \{<,\leq, =, \geq, >\}
	\mathcal{C}:= \{C_{1}\leq \dots \leq C_{n}\}\\  %\sim\in \{<,\leq, =, \geq, >\}
	\mathcal{M^{\mathcal{A}}}:= a^{\mathcal{A}}_{S_{i},C_{j}}\mid \neg \phi^{\mathcal{A}}_{i,j}\mid \phi^{\mathcal{A}}_{i,j}\rightarrow \phi^{\mathcal{A}}_{k,l}\mid \phi^{\mathcal{A}}_{i,j}\wedge \phi^{\mathcal{A}}_{k,l}\mid \phi^{\mathcal{A}}_{i,j}\vee \phi^{\mathcal{A}}_{k,l} \mid \bot\\
	mode:= Read(\mathcal{M}^{\mathcal{A}})\mid Write(\mathcal{M}^{\mathcal{A}})\mid Trust(\mathcal{M}^{\mathcal{A}})\\
	RES:= \mathcal{M}^{\mathcal{A}}\mid mode\mid \neg RES\\
	\Gamma^{\mathcal{A}}:= 
	%\{\{\phi^{\mathcal{A}}_{i,j}, \dots, \phi^{\mathcal{A}}_{i,k}\}, \dots, \{\phi^{\mathcal{A}}_{j,l}, \dots, \phi^{\mathcal{A}}_{j,m}\}\}
	\phi^{\mathcal{A}}_{i,j} \mid \phi^{\mathcal{A}}_{i,j} < \phi^{\mathcal{A}}_{k,l} \mid \Gamma^{\mathcal{A}}; \phi^{\mathcal{A}}_{i,j}
	%\{ \phi^{S}_{i}< \dots < \phi^{S}_{n}\}. %\Gamma^{**}:=\{\psi^{**}_{1}, \dots, \psi^{**}_{n}\}\\
	
	\end{array}
	\end{displaymath}
\end{definition}
%

\subsection{Services, Messaging and Protocols}

$\mathcal{M^{\mathcal{A}}}$ is a set of boolean formulae, closed under connectives, expressing messages. The language includes $\bot$ to express conflicts. $\mathcal{A}$ is the set of agents issuing messages and including vehicles $\mathcal{V}$ and RSUs $\mathcal{R}$. Messages are then signed by agents (vehicles or RSU) generating them and with service and characteristic identifiers, so that: $\phi^{v_{i}}_{i,j}$ says that message $\phi$ about service $S_{i}$ and characteristic $C_j$ is generated by vehicle $v_{i}$. We assume here and throughout that both services $\mathcal{S}$ and characteristics $\mathcal{C}$ of services are given as posets. To simplify notation, a message $\phi^{v_{i}}_{S_{i},C_{j}}$ is usually abbreviated as $\phi^{v_{i}}_{{i},{j}}$. $mode$ is a variable for reading, writing and trusting messages, closed under negation. An agent profile $\Gamma^{\mathcal{A}}$ is the current list of all messages collected by the agent either from other agents or from various available sensors and other networks. For the present purposes, the latter ones will be indexed at their first vehicle or RSU collecting it.


\begin{definition}[Formulas]
A formula $\Gamma^{v}_{i} \vdash_{\mathtt{s}} \phi^{v_{j}}_{i,k}$ says that a message $\phi$ about service $i$ and characteristic $k$ signed from agent $v_{j}$  is validly accessed at step $\mathtt{s}\geq 0$ under the profile of agent $v_{i}$.
\end{definition}

\begin{definition}[Validity]
A formula $\vdash_{\mathtt{s}} \phi^{v_{j}}_{i,k}$ says that a message $\phi$ $\phi$ about service $i$ and characteristic $k$ signed from agent $v_{j}$ holds for \textit{any} agent's profile at step $\mathtt{s}$.
\end{definition}

Messages satisfy a ranking based on that of characteristics:

\begin{definition}\label{def:dependencypackages}
$\phi^{v_{j}}_{i,k}<\phi^{v_{j}}_{i,l}$ iff $C_{k}\leq C_{l} \in S_{i}$ 
%
%says that for agent $v_{j}$ the characteristic $k$ of service $i$ is more important or essential than characteristic $l$ for the same service; then $\phi^{v_{j}}_{i,k} \vdash_{\mathtt{s}}  \phi^{v_{j}}_{i,l}$.
\end{definition}

The order relation between service characteristics induces therefore validity under profile: if a characteristic $i$ is essential to another one $l$ with respect to a service $i$ for an agent $v_{j}$, then that agent will be required to obtain a value for  $i$ in order to validly access a value for $l$. 

%This order relation between service characteristics can then be lifted at the level of services. A partial order relation $\leq$ over $\mathcal{S}\times \mathcal{S}$ intuitively expresses that an order is satisfied across services: 
%$S\leq S'$ means that repository $S$ contains a package that satisfies a dependency for a package in $S'$
%
%\begin{definition}\label{def:orderrepos}
%	$S_{i}\leq S_{j}$  iff $\exists \phi^{v_{j}}_{i,k},\phi^{v_{j}}_{j,l}\ s.t.\ \phi^{v_{j}}_{i,k}<\phi^{v_{j}}_{j,l}$.
%\end{definition}
%By the first clause in Definition \ref{def:orderrepos}, 
%$S_{i}< S_{j}$ means therefore that a service $S_{i}$ is essential for a service $S_{j}$ if there is a message concerning a characteristic of the latter which requires a message about a characteristic of the former. 
%The condition for $\leq$ is satisfied by a dependency relation $\phi_{i}^{A}<\phi_{j}^{A}$ between two packages in the same repository $A$. 
%The partial order allows for branching in the hierarchy, so that e.g. $S_{i}<S_{j}<S_{k}$ and $S_{i}<S_{j}<S_{l}$,  i.e. packages in $S_{k},S_{l}$  both require service $S_{j}$ and transitively $S_{i}$, but they have no requirement from each other. 
%By the second clause in Definition \ref{def:orderrepos}, our order relation abstracts from the issue of reciprocal dependencies. As noted in~\cite{DBLP:journals/eceasst/Boender11}, two packages that mutually depend on each other will either be installed together, or not installed at all. They can therefore be considered as a single package for dependency resolution purposes. 


A valid agent profile meets all the requirements and conflicts clauses of all service messages that the user collects.
%Context $\Gamma^{A}$ formalises a list of formulae describing an installation profile with packages from repository $A$, ordered by the dependency relation holding between relevant packages in $A$. 
%An installation profile can be extended by packages obtained by the same repository, denoted by $\Gamma^{A}, \phi^{A}$. 
Rules from Figure \ref{fig:system0} define agent's profile construction from service messages requirements. By Empty Profile, a user profile can be empty (base case); by Message Insertion, the elements in an installation profile are messages; by Requirement Insertion, a profile can be extended by satisfied service requirements; by Profile Extension, if a message holds in an empty profile, it can be added to an existing profile. 
%Notice that unnecessary packages from any repository can still be added: this is possible for packages without dependencies through the Profile Extension rule, but more in general by an application of the Weakening Rule (see Figure \ref{fig:system3}). The result of such a profile extension is denoted by $\Gamma^{A}; \phi^{B}$ and $\Gamma^{A}; \Gamma^{B}$. It is worth noting that Weakening will preserve profile consistency as it requires additionally an instance fo the $trust$ rule (see Figure \ref{fig:system2}). 

\begin{figure*}[h]
	\begin{prooftree}
		\AxiomC{}
		\RightLabel{Empty Profile}
		\UnaryInfC{$\{\}: profile$}
		\DisplayProof
		\qquad
		\AxiomC{$\phi^{v_{j}}_{i,k} \!:\!\mathcal{M}^{v_{j}}$}
		\RightLabel{Message Insertion}
		\UnaryInfC{$ \phi^{v_{j}}_{i,k} \!:\!profile$}
	\end{prooftree}
	
	
	\begin{prooftree}
	   	\AxiomC{$\Gamma^{v_{j}}, \phi^{v_{j}}_{i,k}: profile$}
		\AxiomC{$\Gamma^{v_{j}}, \phi^{v_{j}}_{i,k}\vdash_{\mathtt{s}}  \psi^{v_{k}}_{i,l}$}
		\RightLabel{Requirement Insertion}
		\BinaryInfC{$\Gamma^{v_{j}}, \phi^{v_{j}}_{i,k}< \psi^{v_{k}}_{i,l} \!:\!profile$}
		%\end{prooftree}
	\end{prooftree}


\begin{prooftree}
			\AxiomC{$\Gamma^{v_{i}}: profile$}
			\AxiomC{$\vdash_{\mathtt{s}}  \psi^{v_{k}}_{j,l}$}
			\RightLabel{Profile Extension}
			\BinaryInfC{$\Gamma^{v_{i}};\psi^{v_{k}}_{j,l} \!:\!profile$}
		\end{prooftree}
	
	
	\caption{The System \texttt{(un)SecureND}: Profile Construction Rules}\label{fig:system0}
\end{figure*}




\subsection{Rules for message construction}

The operational rules in Figure \ref{fig:system1} formulate compositionality of messages. 

\begin{figure*}[t]
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}};\Gamma^{v_{j}}: profile$}
		\RightLabel{Atom, for any $\psi^{v_{j}}_{i,l}\in \Gamma^{v_{j}}$}
		\UnaryInfC{$\Gamma^{v_{i}};\Gamma^{v_{j}}\vdash_{\mathtt{s}}  \psi^{v_{j}}_{i,l}$}
		%\end{prooftree}
		\DisplayProof
		\qquad
		%
		%\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}  RES \rightarrow \bot$}
		\RightLabel{$\bot$}
		\UnaryInfC{$\Gamma^{v_{i}}\vdash_{\mathtt{s+1}}  \neg RES$}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l}$}
		\AxiomC{$\Gamma^{v_{j}} \vdash_{\mathtt{s'}}  \psi^{v_{j}}_{i,m}$}
		\RightLabel{$\wedge$-I}
		\BinaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{max(s,s')+1}}  \phi^{v_{i}}_{i,l} \wedge \psi^{v_{j}}_{i,m}$}
		\DisplayProof
		\qquad
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l} \wedge \psi^{v_{j}}_{i,m}$}
		\RightLabel{$\wedge$-E}
		\UnaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s+1}}  \phi/\psi^{v_{i/j}}_{i,l/m}$}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s}}  \phi^{v_{i/j}}_{i,l/m}$}
		\RightLabel{$\vee$-I}
		\UnaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s+1}}  \phi^{v_{i}}_{i,l} \vee \psi^{v_{j}}_{i,m}$}
		\DisplayProof
		\quad
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l} \vee \psi^{v_{j}}_{i,m}$}
		\AxiomC{$\psi^{v_{i/j}}_{i,l/m} \vdash_{\mathtt{s'}}  \xi^{v_{i/j}}_{k,n}$}
		\RightLabel{$\vee$-E}
		\BinaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}  \vdash_{\mathtt{max(s,s')+1}}  \xi^{v_{i/j}}_{k,n}$}
	\end{prooftree}
	
	
	%	with $I\in \{A,B\}, i \in\{1,2\}$ in the above rules.
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}};\phi^{v_{i}}_{i,l}\vdash_{\mathtt{s}}  \psi^{v_{j}}_{i,m}$}
		\RightLabel{$\rightarrow$-I}
		\UnaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s+1}}  \phi^{v_{i}}_{i,l} \rightarrow \psi^{v_{j}}_{i,m}$}
		\DisplayProof
		\qquad
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,l} \rightarrow \psi^{v_{j}}_{i,m}$}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s'}}  \phi^{v_{i}}_{i,l}  $}
		\RightLabel{$\rightarrow$-E}
		\BinaryInfC{$\Gamma^{v_{i}};\phi^{v_{i}}_{i,l}\vdash_{\mathtt{max(s,s')+1}}  \psi^{v_{j}}_{i,m}$}
	\end{prooftree}
	
	
	
	\caption{The System \texttt{(un)SecureND}: Operational Rules}\label{fig:system1}
\end{figure*}

The rule $Atom$ establishes valid content within a user profile and across other profiles with satisfied requirements. 
%In the present version we assume $A<B$.
$\bot$ formulates access to contradictory messages, in which case the profile must be consistent with the negated access. $\wedge$-I allows message composition from distinct profiles; by $\wedge$-E, each composing message can be obtained from the combined profiles (with $I=\{A,B\}$). $\vee$-I says that a combined profile can access any message produced from each of the composing profiles; by the elimination $\vee$-E, each message consistently inferred by each individual profile can also be executed under the extended profile. $\rightarrow$-Introduction expresses inference of a message from a combined profile as inference between messages (Deduction Theorem); its elimination $\rightarrow$-E allows to recover such inference as profile extension (Modus Ponens).

\subsection{Access Rules}

In Figure \ref{fig:system2} we present the access rules on messages. These allow a user's profile to act on messages from a distinct agent. 


%\Gamma^{v_{i}};\Gamma^{v_{j}}\vdash_{\mathtt{s}}  \psi^{v_{j}}_{i,l}
\begin{figure*}[t]
	\centering
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{s}}  \neg mode(\psi^{v_{j}}_{i,l})$}
		\RightLabel{$\neg$-distribution}
		\UnaryInfC{$\Gamma^{v_{i}}\vdash_{\mathtt{s+1}}  mode(\neg \psi^{v_{j}}_{i,l})$}
		\DisplayProof
		\qquad
		%
		\AxiomC{}
		\RightLabel{$\mathit{read}$}
		\UnaryInfC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})$}
		\end{prooftree}
		
       \begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})$}
		\AxiomC{$\Gamma^{v_{i}};\psi^{v_{j}}_{i,l} : profile$}
		\RightLabel{$\mathit{trust}$}
		\BinaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s+1}}   Trust(\psi^{v_{j}}_{i,l} ) $}
	\end{prooftree}
	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})$}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s'}}   Trust(\psi^{v_{j}}_{i,l} ) $}
		\RightLabel{$\mathit{write}$}
		\BinaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s'+1}}   Write(\psi^{v_{j}}_{i,l} ) $}
		\DisplayProof
		\qquad
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   Write(\psi^{v_{j}}_{i,l} ) $}
		\RightLabel{$\mathit{exec}$}
		\UnaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s+1}}   \psi^{v_{j}}_{i,l}  $}
	\end{prooftree}
	
%	\begin{prooftree}
%%		\AxiomC{$\Gamma^{A}\vdash_{\mathtt{s}}   wf$}
%		\AxiomC{$\Gamma^{v_{i}}  \vdash_{\mathtt{s}}  Read(\psi^{v_{j}}_{i,l})\rightarrow \bot $}
%		\RightLabel{DTrust-I}
%		\UnaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   \neg Trust(\psi^{v_{j}}_{i,l} ) $}
%		\end{prooftree}
%		%\DisplayProof
%		%\qquad	
%		
%		\begin{prooftree}
%		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   \neg Trust(\psi^{v_{j}}_{i,l} ) $}
%		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   \neg Trust(\psi^{v_{j}}_{i,l}) \rightarrow \xi^{v_{k}}_{i,m}$}
%		\RightLabel{DTrust-E}
%		\BinaryInfC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   Write(\xi^{v_{k}}_{i,m}) $}
%	\end{prooftree}
%	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}   Read(\psi^{v_{j}}_{i,l})\rightarrow \bot $}
		\AxiomC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\} : profile$}
%		%\vdash_{\mathtt{s}}   wf, $\forall \phi^{A}_{j}\vdash_{\mathtt{s}}  Read(\psi^{B}_{i})\rightarrow \bot $}
		\RightLabel{MTrust-I}
		\BinaryInfC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\} \vdash_{\mathtt{s+1}}   \neg Trust(\neg \psi^{v_{i}}_{i,l})$}
	\end{prooftree}
%	
%
%	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\} \vdash_{\mathtt{s}}   \neg Trust(\neg \psi^{v_{i}}_{i,l})$}
		\AxiomC{$\Gamma^{v_{k}}; \psi^{v_{j}}_{i,j} : profile$}
		\RightLabel{MTrust-E, $\forall v_{k}\prec v_{j}$}
		\BinaryInfC{$\Gamma^{v_{i}}\setminus \{\neg\psi^{v_{i}}_{i,l}\};\Gamma^{v_{k}}\vdash_{\mathtt{s+1}}  Trust(\psi^{v_{j}}_{i,l})$}
	\end{prooftree}
	\caption{The System \texttt{(un)SecureND}: Access Rules}\label{fig:system2}
\end{figure*}

%
$\neg$-distribution expresses profile consistency: if a user profile does not allow inferring a message, then it allows inferring any other message that has no requirements including it. $\mathit{read}$ says that from any consistent profile a message can be read provided its requirements are satisfied (if any). $\mathit{trust}$ works as an elimination rule for $read$: it says that if a message is received and it preserves profile consistency, then it can be trusted. $\mathit{write}$ works as an elimination rule for $trust$: it says that a readable and trustable message can be sent over the network. $\mathit{exec}$ says that every message that is safely installed in a consistent profile holds in it. 

%The Introduction rule for distrust DTrust-I expresses the principle that a message non-consistent with its receiving profile can be negated to be trustworthy; the corresponding elimination DTrust-E uses $\rightarrow$-introduction to induce $write$ of any message consistent with the conflict resolution. 
The rule MTrust-I says that currently held message conflicting with a newly arrived message are mistrusted, i.e. removed from the current profile until none of its consequences are included; the corresponding MTrust-E elimination allows to trust any message consistent with the conflict resolution by removal of the mistrusted message in the user profile, including any required dependency, as expressed by the side condition that requires checking with any other agent who has higher reputation than the sender of the original message. 
%By the latter set of rules, 
%\textit{distrust} is a flag for preventing installation of conflicting external packages, while 
\textit{mistrust} is a flag for facilitating removal of messages present in the user profile conflicting in view of incoming new information. 
%Notice that both untrust functions are triggered by the querying operation on a repository, hence conflicts are highlighted before installation.



We can now offer a more general interpretation of the derivability relation $\vdash_{\mathtt{s}} $ as access and execution of some message under a given user profile:
%
\begin{definition}
	A formula $\Gamma^{v_{i}} \vdash_{\mathtt{s}}  RES$ says that a message from some user $v_{k}$ is validly accessed ($mode(\phi^{v_{k}})$) and eventually inferred ($\phi^{v_{k}}$) within a user profile with messages held by user $v_{i}$ at step $\mathtt{s}$. 
\end{definition}



\subsection{Structural Rules}

Structural rules hold with restrictions for $\mathtt{(un)SecureND}$, see Figure \ref{fig:system3}. As a result the system qualifies as substructural, see e.g. \cite{restall}. Weakening is constrained by an instance of $trust$: it says valid information is preserved under vehicle's profile extension, assuming the latter is provably consistent and therefore no refresh is required. Contraction is constrained by preservation of ordering: it says that removing identical messages from  a vehicle's profile is admissible, with the constraint that the copy from the agent with higher reputation is preserved. Exchange is doubly constrained by order: it says that reorder of messages is admissible if there is no involved dependency between them. Finally, the Cut rule expresses validity under profile extension: if a message $\phi_{i,j}$ is validly for agent $v_{i}$ and after messaging it to $v_{j}$ the latter can infer $\phi_{i,k}$, then $v_{i}$ can infer $\phi_{i,k}$ by setting a message protocol with $v_{j}$.


\begin{figure*}[t]
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,j}$}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{s'}}  Trust(\phi^{v_{j}}_{j,k})$}
		\RightLabel{Weakening}
		\BinaryInfC{$\Gamma^{v_{i}}; \phi^{v_{j}}_{j,k}\vdash_{\mathtt{max(s,s'}+1)}  \phi^{v_{i}}_{i,j}$}
%	\end{prooftree}
\DisplayProof
%	
%		\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \phi^{v_{j}}_{j,k}; \phi^{v_{k}}_{j,k}\vdash_{\mathtt{s}}  \psi^{v_{i}}_{i,j}$}
		\AxiomC{$v_{j} \prec v_{k}$}
		\RightLabel{Contraction}
		\BinaryInfC{$\Gamma^{v_{i}}; \phi^{v_{j}}_{j,k}\vdash_{\mathtt{s+1}}  \psi^{v_{i}}_{i,j}$}
	\end{prooftree}

	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \phi^{v_{i}}_{i,j}; \phi^{v_{i}}_{i,k}\vdash_{\mathtt{s}}  \psi^{v_{i}}_{i,j}$}
		\AxiomC{$\phi^{v_{i}}_{i,j}\nless \phi^{v_{i}}_{i,k}$}
		\RightLabel{Profile Exchange}
		\BinaryInfC{$\Gamma^{v_{i}}; \phi^{v_{i}}_{i,k}; \phi^{v_{i}}_{i,j}\vdash_{\mathtt{s+1}}  \psi^{v_{i}}_{i,j}$}
	\end{prooftree}
%\DisplayProof

	
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}} \vdash_{\mathtt{s}}  \phi^{v_{i}}_{i,j}$}
		\AxiomC{$\Gamma^{v_{j}}, \phi^{v_{i}}_{i,j}\vdash_{\mathtt{s'}}   \phi^{v_{j}}_{i,k}$ }
		\RightLabel{Cut}
		\BinaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{j}}\vdash_{\mathtt{max(s,s')+1}}   \phi^{v_{j}}_{i,k}$}
	\end{prooftree}
	\caption{The System \texttt{(un)SecureND}: Structural Rules}\label{fig:system3}
\end{figure*}

The cut rule justifies the following result:

\begin{theorem}[Normalization]
Any $\mathtt{(un)SecureND}$ derivation with an occurrence $c$ of the $Cut$ rule can be transformed into another derivation with the same end sequent without $c$ using only trust.
\end{theorem}

\begin{proof}
	By induction on the derivation $D$ which is the redex of the cut-elimination. Assuming $c$ is the only Cut rule and it is the last inference rule of the redex, the derivation $D^\prime$ which is the contractum of the cut-elimination contains a descendent of the cut obtained by an instance of Weakening under trust. Because the formula obtained by the cut is, by hypothesis, derivable from the weaker protocol, it will also be derivable from the weaker and the stronger protocol together. When $c$ is not the last inference rule of the redex, then the descendent of the cut will admit all similar Weakenings preserving the one occurring in the cut; those imports by Weakening will occur also in the contractum of the cut rule and can be traced back up to the one formulation of the import that occurs in the cut rule.
\end{proof}

Normalization justifies a safety property of our trust and reputation model over transitive transmissions: for each vehicle $v_{i}, v_{j}, v_{k}$, if $v_{k}$ holds information $\phi_{i,j}$ and this information is passed to $v_{j}$, then every valid message derived from $\phi_{i,j}$ by $v_{k}$ can be inferred by $v_{j}$ assuming the consistency (by trust) of its profile with that of $v_{k}$; similarly now, $v_{j}$ can pass $\phi_{i,j}$ to $v_{i}$, and the latter can infer from there, assuming its profile is consistent with those of $v_{j}, v_{k}$.



\section{Opportunistic Forwarding}

%\subsection{Handshaking Protocol}

In Figure \ref{fig:handshake} we present an example derivation mimicking an handshaking protocol. Here Service 1 identifies the set of messages for this protocol. By Hello Message, a user $v_{i}$ with a well-defined profile with a `hello' message in its recognition service sends the message to the network;   a user $v_{k}$ reading the message and assuming it preserves consistency (e.g. there is no instruction in its profile to ingore messages from $v_{i}$), accepts it and forwards it further, including a `hello' back to $v_{i}$.



\begin{figure*}
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}:profile$}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{1}}  hello^{v_{i}}_{1,1}$}
		\RightLabel{Hello Message}
		\BinaryInfC{$\Gamma^{v_{i}}\vdash_{\mathtt{2}}  Write(hello^{v_{i}}_{1,1})$}
		\end{prooftree}

	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{1}}  Write(hello^{v_{i}}_{1,1})$}
		\AxiomC{$\Gamma^{v_{k}}\vdash_{\mathtt{2}}  Read(hello^{v_{i}}_{1,1})$}
				
		\AxiomC{$\Gamma^{v_{k}}; hello^{v_{i}}_{1,1}:profile$}
		\RightLabel{Response Message}
		\TrinaryInfC{$\Gamma^{v_{k}}; hello^{v_{i}}_{1,1}\vdash_{\mathtt{3}}  Write(hello^{v_{k}}_{1,1})$}
		\end{prooftree}


	\caption{The Handshaking Protocol}\label{fig:handshake}
\end{figure*}


%\subsection{Recipient Selection Protocol}

In Figure \ref{fig:selection}, we present an example derivation mimicking the recipient selection protocol. Here the idea is as follows: after $v_{i}$ broadcasts a `hello' message, $v_{k}, v_{j}$ both receive and accept the message; at this stage a recipient is selected on the basis of the reputation order between $v_{k}$ and $v_{j}$, so that a new profile is built out of $v_{i}$ and the higher of the two recipients, thus mimicking a communication channel.


\begin{figure*}
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{k}}; hello^{v_{i}}_{1,1}\vdash_{\mathtt{1}}  Write(hello^{v_{k}}_{1,1})$}
		\AxiomC{$\Gamma^{v_{j}}; hello^{v_{i}}_{1,1}\vdash_{\mathtt{2}}  Write(hello^{v_{j}}_{1,1})$}
		\AxiomC{$v_{k} \prec v_{j}$}
		\RightLabel{Recipient Selection}
		\TrinaryInfC{$\Gamma^{v_{i}}; \Gamma^{v_{k}}:profile$}
		\end{prooftree}

	\caption{The Handshaking Protocol}\label{fig:selection}
\end{figure*}


%\subsection{Message Passing Protocol}

In Figure \ref{fig:mp}, we present an example derivation mimicking the message passing protocol (without mistrust). Here Service 2 is some service of any kind. By the first premise in MP, the Handshaking Protocol is guaranteed terminating, including the Recipient Selection protocol if required; $v_{k}$ then reads a message issued by $v_{i}$, checks for validity in its own profile through an application of $trust$, and if this check is passed the message is forwarded.



\begin{figure*}
	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{k}}:profile$}
		\AxiomC{$\Gamma^{v_{i}}\vdash_{\mathtt{1}}  Write(m^{v_{i}}_{2,1})$}
		\RightLabel{MP}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{2}}  Read(m^{v_{i}}_{2,1})$}
		\AxiomC{$\Gamma^{v_{k}}; m^{v_{i}}_{2,1}: profile$}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{3}}  Trust(m^{v_{i}}_{2,1})$}
		\UnaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{4}}  Write(m^{v_{i}}_{2,1})$}
		\end{prooftree}

	\caption{The Message Passing Protocol}\label{fig:mp}
\end{figure*}




\section{Reputation Model}

In this section we illustrate the definition of the order relation $\prec$ to formalise the reputation model across agents. Higher reputation is modelled by feedback aggregation. Our system integrates the elements of the main feedback 6-tuple function from \cite{glenford}. In particular, time is mimicked directly by derivation steps; context is embedded by the user profile; service and characteristics are modelled by messages. To model the set of feedback that a given agent provides with respect to a given message related to a service and characteristic, we will have to collect all formulas following receiving a message:

\begin{definition}[Feedback Set]
The feedback set of agent $v_{j}$ for a message $\phi^{v_{i}}_{i,j}$, for all $v_{j}, v_{i} \in \mathcal{A}$ is the set of formulas $\psi^{v_{j}}_{i,k}$ such that they agree with $\phi^{v_{i}}_{i,j}$ for the service identifier $i$ and are obtained by a derivation construed by a $read$ rule followed by a $\rightarrow I$ rule, i.e.

\[
FS^{v_{j}}(\phi^{v_{i}}_{i,j})=\{ \psi^{v_{j}}_{i,k}\mid \Gamma^{v_{j}}
\vdash_{\mathtt{s}}  Read(\phi^{v_{i}}_{i,j})\rightarrow \psi^{v_{j}}_{i,k}  \}
\]

\end{definition}


By way of example, consider the following simple derivation, which induces $FS^{v_{k}}(m^{v_{i,j}}_{2,1})=\{m^{v_{k}}_{2,2}\}$: 

\begin{figure*}
\begin{footnotesize}

	\begin{prooftree}
		\AxiomC{$\Gamma^{v_{i}}; \Gamma^{v_{k}}:profile$}
		\AxiomC{$\Gamma^{v_{j}}; \Gamma^{v_{k}}:profile$}
		\BinaryInfC{$\Gamma^{v_{i}};\Gamma^{v_{j}}; \Gamma^{v_{k}}:profile$}
		
		\AxiomC{$\Gamma^{v_{k}}\vdash_{\mathtt{1}}  Write(m^{v_{i,j}}_{2,1})$}
%		\AxiomC{$\Gamma^{v_{k}}\vdash_{\mathtt{s}}  Write(m^{v_{j}}_{2,1})$}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{2}}  Read(m^{v_{i,j}}_{2,1})$}
		\AxiomC{$\Gamma^{v_{k}}; m^{v_{i,j}}_{2,1}: profile$}
		\BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{3}}  Trust(m^{v_{i,j}}_{2,1})$}
		\UnaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{4}}  Write(m^{v_{i,j}}_{2,1})$}
		\AxiomC{$\Gamma^{v_{k}}; m^{v_{i,j}}_{2,1}\vdash_{\mathtt{5}}  m^{v_{k}}_{2,2}$}
        \BinaryInfC{$\Gamma^{v_{k}} \vdash_{\mathtt{6}}  m^{v_{i}}_{2,1} \rightarrow m^{v_{k}}_{2,2}$}
		\end{prooftree}
\end{footnotesize}


	\caption{An Example Feedback Set}\label{fig:ask}

\end{figure*}

Notice that by construction this set includes only feedback to received messages that are consistent with the current user's profile. 

\begin{definition}[Agent's Perception]
The perception of agent $v_{j}$ for a message $\phi^{v_{i}}_{i,j}$, for all $v_{j}, v_{i} \in \mathcal{A}$ is the sum of elements of the feedback set over that formula, weighted by the step of the derivation at which it is obtained: 

\[
AP^{v_{j}}(\phi^{v_{i}}_{i,j})=\sum_{FS^{v_{i}}(\phi^{v_{j}}_{i,k})}(\mathtt{s}(\psi^{v_{j}}_{i,k} \in FS^{v_{i}}(\phi^{v_{j}}_{i,k})))
%\mid \Gamma^{v_{j}}
%\vdash_{\mathtt{s}}  Read(\phi^{v_{i}}_{i,j})\rightarrow \psi^{v_{j}}_{i,k}  \}
\]

\end{definition}

Intuitively, the value of $\mathtt{s}$ at each step of each derivation leading to each formula in the feedback set of an agent to a given service and characteristic is summed up to provide a value that increases linearly to reflect a step value for a time function. The value of $AP^{v_{j}}(\phi^{v_{i}}_{i,j})$ will reflect the aggregation of all the feedback provided on each characteristics of a given service.  


We can now generalize to the set of all feedback on a characteristic for a given service, remembering that these are given in a pre-order so that the position of the characteristic in that order is mapped into an integer:


\begin{definition}[Agent's Perception of Characteristic Set]
The perception of agent $v_{j}$ for a set of messages $\mathcal{M}^{\mathcal{A}}_{S_{i}}$ from agents in $\mathcal{A}$ about service $S_{i}$ 
is the sum of elements of the feedback set over the messages received about that service, weighted by the steps of the derivation at which it is obtained and further by the value $\mathtt{r}(C_{k})$ of the rank of characteristic $k$: 


\begin{displaymath}
\begin{array}{l}

AP^{v_{j}}(\mathcal{M}^{\mathcal{A}}_{S_{i}, C_{k}})=\\
\sum_{FS^{v_{i}}(\phi^{v_{j}}_{i,k}\dots \phi^{v_{n}}_{i,k})}
(1-\mathtt{r}(C_{k})(\mathtt{s}(\psi^{v_{j}}_{i,k} \in FS^{v_{i}}(\phi^{v_{j}}_{i,k}\dots \phi^{v_{n}}_{i,k}))))
\end{array}
\end{displaymath}

\end{definition}


Using the agent's perception of characteristic set, we can define the order of reputation with respect to services and characteristics, which establishes a higher position for the agent whose perception on the characteristics set for that Service is greater.

\begin{definition}[Reputation]
$\forall v_{i}, v_{j}\in \mathcal{V}, S_{i}\in \mathcal{S}, v_{i}\prec v_{j} \leftrightarrow AP^{v_{i}}(\mathcal{M}^{\mathcal{A}}_{S_{i}, C_{k}})>AP^{v_{j}}(\mathcal{M}^{\mathcal{A}}_{S_{i}, C_{k}})$.
\end{definition}

\section{Conclusions}

In this paper we have formulated a proof-theory for trust and reputation in VANETs. Our language is modelled on the logic \texttt{(un)SecureND}, including an explicit $trust$ function on formulas to guarantee consistency check at each retrieval step (after a $read$ function), before forwarding is granted for a package (by a $write$ function). Forwarding is modelled in an opportunistic fashion, selecting receivers on the basis of their reputation ranking. Trust on forwarding also guarantees correctness on transitive transmissions. Moreover, reputation is used to implement the resolution protocol for restoring information after removing previously stored data.
% Different pairs of introduction/elimination rules determine the selection of one of tow resolution strategies: one flags a package external to the installation profile as distrusted and hence as not installable; the other identifies already installed packages to be removed. The selection takes care to identify and remove all required dependencies. We have illustrated the working protocol through an easy example. 
Validation of the system is obtained by implementation of the \texttt{(un)SecureND} calculus as a large inductive type in the Coq proof assistant. The development is available at \url{https://github.com/gprimiero/SecureNDC}. 
%It makes it possible to express and prove the lemmas and theorems from sections~\ref{sec:distrusted} and~\ref{sec:mistrusted}.
A characteristic of the logic \texttt{(un)SecureND} is its substructural nature, which in future work can be exploited to investigate cases of strengthened and limited resource redundancy for fault tolerance and source shuffling for security. Other applications of negative trust can be investigated to distinguish between malevolent and simply unsuccessful sources.


\bibliographystyle{plain}
\bibliography{unsecureNDC}

\end{document}



\section{The Distrusted Uninstall Problem}\label{sec:distrusted}



Consider a profile $\Gamma^{A}=\{\phi_{1}^{A}< \dots< \phi_{n}^{A}\}$ and a package $\phi_{m}^{B}$ which one wishes \textit{not to install}. This might be due to a principled decision or an explicit conflict in view of an installed package, which one explicitly wants to preserve. We call such a package $\phi_{m}^{B}$ \textit{distrusted}. In the calculus, this corresponds to the conclusion of the DTrust-I rule

$$\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})$$

The \textit{Distrusted Uninstall Problem} is to determine which packages can be installed in $\Gamma^{A}$ that do not depend from $\phi_{m}^{B}$. Our formulation allows to express this principle as the request to obtain the maximal set of formulas $\{\psi_{i}^{N}\}$ from any repository $N\geq B$ such that 

$$\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})\rightarrow \{\psi_{i}^{N}\}$$

By DTrust-E, this guarantees the right to install $\psi_{i}^{N}$. 

The first step consists in transforming our problem in a formulation that removes the trust condition.

\begin{lemma}
	$\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})\rightarrow \psi_{i}^{N}$ iff $\Gamma^{A}; \neg \phi_{m}^{B}\vdash_{\mathtt{s}}  \psi_{i}^{N}$.
\end{lemma}

\begin{proof} 
	For the left-to-right direction: By the assumption $\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})$ and $\neg$-distribution, $\Gamma^{A}\vdash_{\mathtt{s}}  Trust(\neg \phi_{m}^{B})$; by the same rule and the premise $\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})\rightarrow \psi_{i}^{N}$ we get $\Gamma^{A}\vdash_{\mathtt{s}}  Trust( \neg\phi_{m}^{B})\rightarrow \psi_{i}^{N}$. Now apply $write$ to both occurrences of $Trust( \neg\phi_{m}^{B})$ and eliminate the function through $exec$; by $\rightarrow$-E we obtain $\Gamma^{A}; \neg \phi_{m}^{B}\vdash_{\mathtt{s}}  \psi_{i}^{N}$.
	
	For the right-to-left direction: By the assumption $\Gamma^{A}; \neg \phi_{m}^{B}\vdash_{\mathtt{s}}  \psi_{i}^{N}$ it holds $\Gamma^{A}; \neg \phi^{B}_{m}: profile$, which justifies $\Gamma^{A}\vdash_{\mathtt{s}}  Read(\neg \phi^{B}_{m})$ by $read$, $\Gamma^{A}\vdash_{\mathtt{s}}  Trust(\neg \phi^{B}_{m})$ by the previous and $trust$ and $\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust( \phi^{B}_{m})$ by $\neg$-distribution. It follows $\Gamma^{A}; \neg Trust( \phi^{B}_{m})\vdash_{\mathtt{s}}  \psi_{i}^{N}$ by substitution from the assumption, and $\Gamma^{A}\vdash_{\mathtt{s}}  \neg Trust(\phi_{m}^{B})\rightarrow \psi_{i}^{N}$ is obtained by $\rightarrow$-I.
	%By $trust$, $write$, $\rightarrow$-E and $\neg$-distribution.
\end{proof}


We can now reduce the latter to an operation on all packages coming from the repository involved by the distrust operation:


\begin{lemma}\label{th:setminus}
	%The Distrust Uninstall Problem is equivalent to a proof of 
	If $\Gamma^{A}; \neg \phi_{m}^{B}\vdash_{\mathtt{s}}  \psi_{i}^{N}$ then $\Gamma^{A}; \Gamma^{B}\setminus \{\phi_{m}^{B}\}\vdash_{\mathtt{s}}  \psi_{i}^{N}$.
\end{lemma}

\begin{proof} 
	
$\Gamma^{A}$ can be extended with every package from $B$; by definition $\Gamma^{A}; \neg \phi_{m}^{B}\vdash_{\mathtt{s}}  \neg Trust(\phi^{B}_{m})$, hence by Weakening this is possible except for $\phi^{B}_{m}$ as it does not satisfy $trust$.
\end{proof}

The above corresponds to finding the maximal set of formulas in $\Gamma^{B}$ that allows to execute $\psi_{i}^{N}$ without requiring $\phi_{m}^{B}$ in the profile. To this aim, it is enough to find all $\phi_{l}^{B}\nless\phi_{m}^{B}$, i.e. the set of packages in $B$ that have no dependencies from $\phi_{m}^{B}$. 

What has been so far restricted to one repository, can now be generalised to any repository that preserves the dependency condition:


\begin{lemma}\label{th:gen}
	$\Gamma^{A};\phi_{l}^{N}\vdash_{\mathtt{s}}  Write(\phi_{i}^{N})$ iff 
	%$(\phi_{l}^{N}<\phi_{m}^{N})$ 
	$(\phi_{l}^{N}\nless \phi_{m}^{N} \nless \psi^{N}_{i})$  for any distrusted package $\phi_{m}^{N}$ and any repository $N> A$.
\end{lemma}

\begin{proof} 
	For the right-to-left direction. Assume the following: $\Gamma^{A};\phi_{l}^{N}\vdash_{\mathtt{s}}  Write(\phi_{i}^{N})$ and $\Gamma^{A};\phi_{l}^{N}\vdash_{\mathtt{s}}  \neg Trust(\phi^{N}_{m})$. Then: if $\phi^{N}_{l}< \phi^{N}_{m}$, then $\Gamma^{A}; \phi^{N}_{l}\vdash_{\mathtt{s}}  \phi^{N}_{m}$ by Atom, contradicting the distrust assumption; and if $\phi^{N}_{m}< \phi^{N}_{i}$ then similarly $\phi^{N}_{m}\vdash_{\mathtt{s}}  \phi^{N}_{i}$ and by Weakening it is possible to obtain $\Gamma^{A};\phi_{l}^{N},\phi^{N}_{m} \vdash_{\mathtt{s}}  Write(\phi_{i}^{N})$, again contradicting the distrust assumption.
	
	For the left-to-right direction. Assume $(\phi_{l}^{N}\nless \phi_{m}^{N} \nless \phi^{N}_{i})$ and $\Gamma^{A};\phi_{l}^{N}\vdash_{\mathtt{s}}  \neg Trust(\phi^{N}_{m})$. Then: because $\phi_{l}^{N}\nless \phi_{m}^{N}$, the second assumption above does not require to remove $\phi_{l}^{N}$ as by Lemma \ref{th:setminus}; and because $\phi_{m}^{N} \nless \phi^{N}_{i}$, installing the latter does not require installing the former, as prescribed by Definition \ref{def:dependencypackages} via the $exec$ rule. Hence $\Gamma^{A};\phi_{l}^{N}\vdash_{\mathtt{s}}  Write(\phi_{i}^{N})$ holds.
\end{proof}

Finally, our main result is obtained:

\begin{theorem}(\textbf{Distrusted Uninstall})
	Given a package $\phi^{B}_{m}$ distrusted under profile $\Gamma^{A}$, a package $\phi^{N}_{i}$ can be installed in $\Gamma^{A}$ iff $\phi^{B}_{m}\nleq \phi^{N}_{i}$.
\end{theorem}

\begin{proof} 
	From Definition \ref{def:distrustedproblem} and Lemma \ref{th:gen} by substitution.
\end{proof}

This last result identifies distrusted packages as those that have at least a dependency from one package conflicting with the current installation profile.


\section{The Mistrusted Uninstall Problem}\label{sec:mistrusted}

Consider a profile $\Gamma^{A}=\{\phi_{1}^{A}, \dots, \phi_{n}^{A}\}$, and a package $\phi^{B}_{m}$ which one wishes to install in it: in the calculus, this corresponds to the conclusion of an instance of the Write rule, $\Gamma^{A}\vdash_{\mathtt{s}}  Write(\phi^{B}_{m})$. Assume that $\phi^{B}_{m}$ is in conflict with the given profile 

$$\Gamma^{A}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m}) \rightarrow \bot$$

The \textit{Mistrusted Uninstall Problem} is to determine the set $\{\phi^{A}_{i}\}$ of packages in $\Gamma^{A}$ that are in conflict with $\phi^{B}_{m}$ and which should be removed when installing it. We will call any such package $\phi^{A}_{i}$ a \textit{mistrusted package}. Hence the problem is to identify the minimal set of formulas $\phi_{i}^{A}$ such that

$$\Gamma^{A}\setminus \{\phi^{A}_{i}\}; \phi^{B}_{m}\vdash_{\mathtt{s}}  \neg Trust(\phi^{A})$$

and by MTrust-E, given any other set of formulas $\Gamma^{C}$ required by $\phi^{B}_{m}$, it allows 

$$\Gamma^{A}\setminus \{\phi^{A}_{i}\}; \Gamma^{C} \vdash_{\mathtt{s}}  Trust(\phi^{B}_{m})$$


We start by identifying the minimal subset of packages from the current installation profile that satisfies the conflict:

\begin{lemma}\label{th:gen2}
	If $\Gamma^{A}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$, then $\exists \Gamma'^{A}\subseteq\Gamma^{A}$
	such that $ \Gamma'^{A}=\{\phi^{A}_{i}< \dots< \phi^{A}_{n}\} \vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$.
%such that $\Gamma'^{A}\ni \phi^{A}_{i}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$ and $\forall \phi^{A}_{j}> \phi^{A}_{i}, \phi^{A}_{j}\in \Gamma'^{A}$
\end{lemma}
%
\begin{proof} 
$\forall \phi^{A}_{i}, \phi^{A}_{j}\in \Gamma^{A}$, if $\phi^{A}_{i}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$ and $\phi^{A}_{i}<\phi^{A}_{j}$, then $\phi^{A}_{j}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$. And $\forall \phi^{A}_{h}<\phi^{A}_{i}$, $\phi^{A}_{h}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})$. Hence it suffices to identify the maximal $\phi^{A}_{i}$ in conflict with $\phi^{B}_{m}$ and to include it in $\Gamma'^{A}$ together with all packages in $\Gamma^{A}$ that depend from it. We will call $\Gamma'^{A}$ a maximally mistrusted set.
\end{proof}


\begin{lemma}\label{th:gen3.0}
Consider a maximally mistrusted $\Gamma'^{A}\subseteq \Gamma^{A}$ such that\\ $ \Gamma'^{A} \vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$ as of Lemma \ref{th:gen2}. Then $\forall \phi^{A}_{i}\in \Gamma'^{A}$, $\phi^{A}_{i} < Read(\phi^{B}_{m})\rightarrow \bot$.
\end{lemma}

\begin{proof}
This holds by construction of $\Gamma'^{A}$ in Lemma \ref{th:gen2} and the Dependency Insertion Rule.
\end{proof}

%\begin{definition}
%	If $\phi^{A}_{i}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$ then $\forall \phi^{A}_{j}>\phi^{A}_{i}, \phi^{A}_{j}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$.
%\end{definition}



\begin{lemma}\label{th:gen3}
	If $\phi^{A}_{i}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$, then $ \phi^{A}_{i}\nless \phi_{m}^{B}$.
\end{lemma}
%
%\begin{proof} 
%XX
%\end{proof}
%
%
%\begin{theorem}\label{th:mis1}
%	$\Gamma^{A}\setminus \{\phi^{A}_{i}\}; \Delta^{C} \vdash_{\mathtt{s}}  Trust(\phi^{B}_{m})$ iff $ \phi^{A}_{i}\nless \phi_{m}^{B}$.
%\end{theorem}

\begin{proof} 
Staring from $\phi^{A}_{i}\vdash_{\mathtt{s}}  Read(\phi^{B}_{m})\rightarrow \bot$ we apply D-Trust-I, $\neg$-distribution, $write$ and  $exec$ to obtain $\phi^{A}_{i}\vdash_{\mathtt{s}}  \neg \phi^{B}_{m}$, from which we can obtain $\phi^{A}_{i}< \neg \phi^{B}_{m}$ from Dependency Insertion and $\phi^{A}_{i}\nless \phi^{B}_{m}$ by contrapposition.

\end{proof}


%To obtain the set $\{\phi^{A}_{i}\}$, we need to check $$\forall \phi_{i}^{A}\in\Gamma^{A}, \phi^{A}_{i}\vdash_{\mathtt{s}}  Trust(\phi_{m}^{B})$$
%i.e. any formula in $\Gamma^{A}$ such that it satisfies dependencies for our conflicting package. This problem is equivalent to

%\begin{theorem}
%	$\phi_{i}^{A}\vdash_{\mathtt{s}}  Write(\phi_{m}^{B})$ iff $(\phi_{i}^{A}<\phi_{m}^{B}) \in\Gamma^{B}$.
%\end{theorem}






\begin{theorem}(\textbf{Mistrusted Uninstall})
	Given a package $\phi^{B}_{m}$ to be installed under profile $\Gamma^{A}$, a package $\phi^{A}_{i}$ is mistrusted in $\Gamma^{A}$ iff 
	\begin{enumerate}
	\item $\phi^{A}_{i}\leq \phi^{A}_{j}$
	\item $\phi^{A}_{j}< Read(\phi^{B}_{m})\rightarrow \bot$ and
	\item $\phi^{A}_{i}\nless \phi^{B}_{m}$.
	\end{enumerate}
	
	%$\phi_{i}^{A}\leq \neg \phi^{B}_{m}$.
	%$\phi_{i}^{A}\leq \neg \phi^{B}_{m}$.
\end{theorem}

\begin{proof}
The first condition is required by Lemma \ref{th:gen3.0} to include all the dependencies in the maximally mistrusted set. The second condition holds from Lemma \ref{th:gen3}. Finally, the third condition holds by contradiction: if $\phi^{A}_{i}< \phi^{B}_{m}$, then $\phi^{A}_{i}\vdash_{\mathtt{s}}  \phi^{B}_{m}$ by Dependency Insertion; it follows by Weakening that $\phi^{A}_{i}; \phi^{B}_{m}: profile$ and hence $\phi^{B}\vdash_{\mathtt{s}}  Trust (\phi^{A}_{i})$.
\end{proof}


This last result identifies packages to be removed as those that are in maximally mistrusted set and do not satisfy any dependency for the package to be installed under the current profile.



\section{An Example}\label{sec:example}

Consider the following scenario. A user on a Debian based system has the following installation profile:



$$
\Gamma^{m-f-nf}
\left\{
\begin{array}{l}
\Gamma^{main}=\{\phi^{m}_{1},\phi^{m}_{2}\}\\
\Gamma^{free}=\{\psi^{f}_{1}\}\\
\Gamma^{nonfree}=\{\xi^{nf}_{1}\}\\
\end{array}
\right\}
$$

with the following dependencies

$$
\Gamma^{m-f-nf}
\left\{
\begin{array}{l}
\phi^{m}_{1}<\psi^{f}_{1}\\
\phi^{m}_{2}<\psi^{f}_{1}\\
\psi^{f}_{1}<\xi^{nf}_{1}\\
\end{array}
\right\}
$$
Assume the user distrusts a package $\psi^{f}_{n}$, e.g. because it is considered harmful or unsecure. The Distrusted Uninstall Problem asks which packages can be further installed in $\Gamma^{m-f-nf}$ without installing $\psi^{f}_{n}$.  Consider now a package $\psi^{f}_{2}\ngtr \psi^{f}_{n}$, then the following derivation holds:


\begin{prooftree}
		%\noline
		
		\AxiomC{D}
						\UnaryInfC{$\Gamma^{m-f-nf}\vdash_{\mathtt{s}}  \neg Trust(\psi^{f}_{n})$}		
					\AxiomC{D'}
				
		\UnaryInfC{$\Gamma^{m-f-nf}\vdash_{\mathtt{s}}  Read(\psi^{f}_{2})$}
		\AxiomC{$\psi^{f}_{n}\nless \psi^{f}_{2}$}
	%	\AxiomC{$\Gamma^{m-f-nf}; \psi^{f}_{2}\vdash_{\mathtt{s}}  wf$}		
		\RightLabel{}
%		\TrinaryInfC{$\Gamma^{m-f-nf}; \psi^{f}_{2}\vdash_{\mathtt{s}}  wf$}
			\TrinaryInfC{$\Gamma^{m-f-nf}\vdash_{\mathtt{s}}  Write(\psi^{f}_{2})$}
	\end{prooftree}
In other words the flagging of $\psi^{f}_{n}$ as distrustful does not impede the installation of a package $\psi^{f}_{2}$ if the latter does not depend on the former.

Assume moreover that the user wishes to install an additional package $\xi^{nf}_{2}>\phi^{m}_{1}$, but such that  $\phi^{m}_{2}\vdash_{\mathtt{s}}  Read(\xi^{nf}_{2})\rightarrow \bot$: in other words, $\xi^{nf}_{2}$ depends from $\phi^{m}_{1}$, but is in conflict with $\phi^{m}_{1}$ (which is possible, given the latter does not depend on $\phi^{m}_{1}$). Then assuming a package $\psi^{f}_{2}$ replacing the functionalities of $\phi^{m}_{2}$,  the following derivation holds:


 
\begin{prooftree}
		%\noline
		
		\AxiomC{$\phi^{m}_{2}\vdash_{\mathtt{s}}  Read(\xi^{nf}_{2})\rightarrow \bot$}
		\AxiomC{$\phi^{m}_{2}<\psi^{f}_{1}$}
						\BinaryInfC{$\Gamma^{m-f-nf}\setminus \{\phi^{m}_{2}<\psi^{f}_{1}\}; \xi^{nf}_{2}\vdash_{\mathtt{s}}  \neg Trust(\phi^{m}_{2}<\psi^{f}_{1})$}		
						\AxiomC{$\psi^{f}_{2};\xi^{nf}_{2}: profile$}
				
		\BinaryInfC{$\Gamma^{m-f-nf}\setminus \{\phi^{m}_{2}<\psi^{f}_{1}\}; \xi^{nf}_{2}\vdash_{\mathtt{s}}  Write(\psi^{f}_{2})$}
	\end{prooftree}
In other words the installation of $\xi^{nf}_{2}$ requires removing $\phi^{m}_{2}<\psi^{f}_{1}$ and it is compatible with the installation of $\psi^{f}_{2}$.


%\section{The \texttt{(un)SecureNDC} Coq Library}



%\section{References}
%Generated by bibtex from your ~.bib file.  Run latex,
%then bibtex, then latex twice (to resolve references)
%to create the ~.bbl file.  Insert that ~.bbl file into
%the .tex source file and comment out
%the command \texttt{{\char'134}thebibliography}.
% This next section command marks the start of
% Appendix B, and does not continue the present hierarchy
%\section{More Help for the Hardy}
%The sig-alternate.cls file itself is chock-full of succinct
%and helpful comments.  If you consider yourself a moderately
%experienced to expert user of \LaTeX, you may find reading
%it useful but please remember not to change it.
%\balancecolumns % GM June 2007
% That's all folks!

\section{Conclusions}

In this paper we have formulated two variants to the Uninstall Problem. Each relies on a different semantic qualification of untrusted packages required to be removed or prevented from installation in a given installation profile, in order to preserve consistency. 

Our approach is grounded on the logic \texttt{(un)SecureND}, including an explicit $trust$ function on formulas to guarantee consistency check at each retrieval step (after a $read$ function), before installation rights are granted for a package (by a $write$ function). The fragment of the language presented in this paper allows to express negation over trust, thereby expressing a dis-installation requirement. Different pairs of introduction/elimination rules determine the selection of one of tow resolution strategies: one flags a package external to the installation profile as distrusted and hence as not installable; the other identifies already installed packages to be removed. The selection takes care to identify and remove all required dependencies. We have illustrated the working protocol through an easy example. 

Validation of the system is obtained by implementation of the \texttt{(un)SecureND} calculus as a large inductive type in the Coq proof assistant. The development is available at \url{https://github.com/gprimiero/SecureNDC}. It makes it possible to express and prove the lemmas and theorems from sections~\ref{sec:distrusted} and~\ref{sec:mistrusted}.

A characteristic of the logic \texttt{(un)SecureND} is its substructural nature, which in future work can be exploited to investigate cases of strengthened and limited resource redundancy for fault tolerance and source shuffling for security. Other applications of negative trust can be investigated to distinguish between malevolent and simply unsuccessful sources.



\bibliographystyle{plain}
\bibliography{unsecureNDC}
\end{document}
